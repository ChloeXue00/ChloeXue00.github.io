<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Gymnasium | </title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="/tags/gymnasium/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="/tags/gymnasium/index.xml">
<link rel="alternate" hreflang="en" href="/tags/gymnasium/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="/tags/gymnasium/">
  <meta property="og:title" content="Gymnasium">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gymnasium">
<meta name="twitter:description" content="">



</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">
  <main id="main">
    <h1 class="page-title">Gymnasium</h1>

    
    
    

    
      <h2 style="margin-top: 2rem;">Projects</h2>
      <div class="post-list">
        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/quadtree_integrate_mpc/">四叉树与 MPC 集成在机器人导航中的应用</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><hr>
<h2 id="总览">总览</h2>
<p>本篇文档介绍了如何将<strong>四叉树（QuadTree）空间表示法</strong>与**模型预测控制（MPC）**集成，用于复杂环境下的机器人路径规划。</p>
<p>该架构的优势在于：</p>
<ol>
<li><strong>四叉树</strong> 提供了适应环境复杂度的空间划分与凸包区域</li>
<li><strong>MPC</strong> 可在动态、带约束的前瞻性框架下生成最优控制</li>
</ol>
<p>核心思想是：将四叉树节点生成的<strong>凸包区域</strong>转化为<strong>线性不等式约束</strong>，供 MPC 在轨迹优化中使用，完成避障与路径限制。</p>
<hr>
<h2 id="架构图">架构图</h2>
<pre tabindex="0"><code>   
环境地图 ────► 四叉树分解 ────►凸包生成 

                                            │
                                            ▼

机器人控制 ◄──── MPC优化器 ◄────线性几何约束
</code></pre><hr>
<h2 id="四叉树地图表示">四叉树地图表示</h2>
<p>四叉树将环境划分为不同分辨率的空间单元：</p>
<ul>
<li>开放区域使用较大的节点</li>
<li>障碍物附近使用更小的细节节点</li>
<li>仅保留表示自由区域的叶子节点</li>
</ul>
<h3 id="优势">优势</h3>
<ul>
<li><strong>自适应分辨率</strong>：按需细化，避免资源浪费</li>
<li><strong>内存友好</strong>：比统一网格更节省存储</li>
<li><strong>支持多分辨率路径规划</strong></li>
</ul>
<hr>
<h2 id="凸包区域构建">凸包区域构建</h2>
<p>四叉树分解完成后：</p>
<ol>
<li>将每个自由叶子节点看作不规则区域</li>
<li>为每个叶子节点生成一个凸包（Convex Hull）</li>
<li>这些凸包表示机器人可以安全通行的区域</li>
<li>邻接凸包间连接形成路径图
<img alt="四叉树分解链接凸包形成路径图" loading="lazy" src="/images/quadtree_path_planning.png"></li>
</ol>
<hr>
<h2 id="mpc-所需的约束生成方式">MPC 所需的约束生成方式</h2>
<p>对于路径经过的每个凸包区域：</p>
<ol>
<li>凸包每条边转化为半空间线性约束 <code>ax + by + c ≤ 0</code></li>
<li>约束的法向量需朝向<strong>凸包外部</strong></li>
<li>保证 MPC 优化轨迹始终在凸包（安全区）内</li>
</ol>
<p>数学上，对于边 <code>(x₁,y₁)</code> → <code>(x₂,y₂)</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>a = -(y₂ - y₁)
</span></span><span style="display:flex;"><span>b =  (x₂ - x₁)
</span></span><span style="display:flex;"><span>c = -ax₁ - by₁
</span></span></code></pre></div><p>约束形式为：<code>ax + by + c ≤ 0</code></p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 17, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/narrow_exploration/">如何训练用于狭窄通道规划的 DRL 策略？</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><hr>
<h2 id="狭窄通道">在这个混合路径规划系统中，DRL 策略负责接管那些局部空间极端受限、传统 MPC 难以生效的区域，特别是“狭窄通道（narrow passage）”问题。为此，我们构建了一个专门应对该类场景的 DRL 策略，并通过 TD3 或 DDPG 算法进行训练。
<img alt="狭窄通道" loading="lazy" src="/images/hybrid_image_result.png"></h2>
<h2 id="1-使用的算法与损失函数">1. 使用的算法与损失函数</h2>
<p>我们使用 <strong>TD3 或 DDPG</strong> 算法，分别训练策略网络（Actor）和价值网络（Critic）。</p>
<h3 id="ddpg">DDPG</h3>
<p>DDPG 有时能够实现出色的性能，但它在超参数和其他类型的调优方面往往很脆弱。DDPG 的一个常见故障模式是，学习到的 Q 函数开始大幅高估 Q 值，从而导致策略破坏，因为它利用了 Q 函数中的误差。</p>
<h3 id="td3">TD3</h3>
<p>td3 在DDPG基础上做到了三个技巧的更新，解决DDPG Q值过高的问题</p>
<ul>
<li>
<p>技巧1： 裁剪双Q学习
TD3学习两个Q函数 而不是一个（因此称为twin），并使用两个Q值比较小的一个作为bellman误差损失函数中的目标</p>
</li>
<li>
<p>技巧2： “延迟”策略更新
TD3 更新策略和目标网络的频率低于Q函数，本文建议没更新两次Q函数就进行依次策略更新</p>
</li>
<li>
<p>技巧2： 目标策略平滑
TD3为目标动作添加了噪声，通过平滑动作中的Q的变化，使策略更难利用Q函数误差
这三个技巧可以显著提高baseline DDPG 的性能</p>
</li>
<li>
<p>TD3 是一种off-policy algorithm</p>
</li>
<li>
<p>TD3 只能用于具有连续动作空间的环境</p>
</li>
<li>
<p>TD3 的Spinning up实现不支持并行化</p>
</li>
</ul>
<p>关键方程式：
TD3通过 均方bellman误差最小化的同时 学习两个Q函数Q_phi_1和Q_phi_2， 其方式于DDPG学习单个Q函数的方式几乎相同，
为了准确展示TD3的实现方式， 以及它与普通DDPG的区别，我们将从损失函数的最内层向外进行讲解。</p>
<ul>
<li>
<p>第一：目标策略平滑
用于构成Q学习目标的动作 基于目标策略/mu_theta_targ , 但在动作的每个维度上添加了截断噪声。添加阶段噪声后，目标动作将被阶段， 使其位于有效动作范围内（所有有效动作，都满足alpha_low &lt;= alpha &lt;= alpha_high）。因此，目标动作如下：
<img alt="目标动作方程" loading="lazy" src="/images/td3_target_action.png">
目标策略平滑本质上充当了算法的正则化器（正则化是一组用于减少机器学习模型中过拟合的方法。正则化会用训练准确性的边际下降来换取泛化性的提高。 正则化包含一系列用于纠正机器学习模型过拟合问题的方法。）
它解决了DDPG中可能出现的一种特殊故障模式：如果Q函数逼近器针对某些动作产生了错误的尖峰，策略就会迅速利用改封至，从而导致脆弱或错误的行为。
这种情况可以通过平滑类似动作的Q函数来避免，
而这正是目标策略平滑的设计初衷。</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 17, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/quadtree_to_mpc/">路径规划（三） 如何将 QuadTree 输出路径接入 MPC 控制器进行轨迹优化？</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><h2 id="背景介绍路径规划--控制的解耦-vs-联合">背景介绍：路径规划 + 控制的解耦 vs 联合</h2>
<p>在移动机器人导航中，路径规划（如基于地图构建的搜索）与轨迹跟踪（如模型预测控制 MPC）通常被拆解为两个阶段：</p>
<ul>
<li><strong>规划模块</strong>：找到一条从起点到目标的无碰路径</li>
<li><strong>控制模块</strong>：跟随这条路径，使机器人平稳、可控地到达目标</li>
</ul>
<p>但在复杂环境中，尤其是动态障碍物、曲折通道等场景中，如果不能做好两者的耦合与接口设计，系统效果会受到很大限制。</p>
<p>本项目采用 <strong>四叉树（QuadTree）划分安全区域 + MPC 控制器跟踪轨迹</strong> 的结构，成功实现了一个典型的路径→控制联合流程。</p>
<hr>
<h2 id="第一步通过-quadtree-提取可行路径">第一步：通过 QuadTree 提取可行路径</h2>
<p>我们使用 <code>connective_quadtree</code> 构建了一个基于图的四叉树分区系统，它可以：</p>
<ul>
<li>在任意障碍物地图上生成 QuadTree 结构</li>
<li>快速查询从 <code>start_pos</code> 到 <code>goal_pos</code> 的路径节点</li>
<li>每个叶子节点有 <code>center()</code>，表示其几何中心</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>path_nodes <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>quadtree<span style="color:#f92672">.</span>find_path(start_pos[:<span style="color:#ae81ff">2</span>], goal_pos[:<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>path_points <span style="color:#f92672">=</span> [node<span style="color:#f92672">.</span>center() <span style="color:#66d9ef">for</span> node_id <span style="color:#f92672">in</span> path_nodes]
</span></span></code></pre></div><p>这里输出的是一个 [(x0, y0), (x1, y1), &hellip;] 的路径点序列，尚不能直接用于控制器输入。</p>
<hr>
<h2 id="第二步mpc-控制器的输入格式要求">第二步：MPC 控制器的输入格式要求</h2>
<p>为了让 MPC 能正常运行，需要如下格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>initial_state <span style="color:#f92672">=</span> [x, y, yaw, v]  <span style="color:#75715e"># 当前状态</span>
</span></span><span style="display:flex;"><span>reference_trajectory <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[x0, y0], [x1, y1], <span style="color:#f92672">...</span>])
</span></span></code></pre></div><p>控制器内部会基于参考轨迹进行插值、预测、代价优化。</p>
<hr>
<h2 id="第三步桥接逻辑实现完整整合流程">第三步：桥接逻辑实现（完整整合流程）</h2>
<p>我们在 <code>trajectory_generator.py</code> 中实现了完整的桥接类 <code>TrajectoryGenerator</code>，封装逻辑如下：</p>
<h3 id="路径转为-mpc-输入轨迹">路径转为 MPC 输入轨迹</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>ref_path <span style="color:#f92672">=</span> PathNodeList([PathNode(p[<span style="color:#ae81ff">0</span>], p[<span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> path_points])
</span></span><span style="display:flex;"><span>self<span style="color:#f92672">.</span>set_ref_trajectory(ref_path)
</span></span></code></pre></div><p>这一过程自动插值生成 <code>TrajectoryNodeList</code>（x, y, theta），最终用于 MPC 滑窗轨迹。</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 16, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/quadtree_safearea/">路径规划（二）从占用图到安全区域：四叉树（QuadTree）构建与凸包生成</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p>在自主移动机器人中，快速判断哪些区域是可通行的、哪些区域需要避障，是路径规划系统的关键。这里我采用 <strong>四叉树结构（QuadTree）</strong> 对占用图进行递归划分，再对空闲区域构建 <strong>凸包（Convex Hull）</strong>，生成**连接图（Connectivity Graph）**从而生成可用于路径规划的安全走廊（Safe Corridor）。</p>
<hr>
<h2 id="一构建思路概览">一、构建思路概览</h2>
<p>参考了项目中 <code>connective_quadtree.py</code> 和 <code>corridor_algorithm.py</code> 中的实现，思路如下：</p>
<pre tabindex="0"><code>1. 输入原始占用图（Occupancy Grid）
2. 使用 QuadTreeNode 递归划分空间, 根据RGB颜色判断：
    - 若区域为空（全白[255,255,255]或者接近全白）：标记为“自由区域”
    - 若包含障碍（RGB值大于白色）：继续细分（最多分到 min_size）
    - 黑色（[0,0,0]）表示障碍物
3. 收集所有自由叶子节点作为 Safe Area 候选
4. 为每个叶子节点生成其凸包边界
5. 输出凸包用于路径规划和约束构建
</code></pre><hr>
<h2 id="二quadtree-类详解connective_quadtreepy">二、QuadTree 类详解（connective_quadtree.py）</h2>
<h3 id="quadtree">Quadtree:</h3>
<pre tabindex="0"><code>Quadtree 是一种树形数据结构，可以用于将二维空间递归划分成更小的矩形区域（占用和空闲区域），
从整张地图作为根节点开始分裂出四个子区域，每个子区域根据RGB值判断是否有障碍物。
</code></pre><p>基于原始图像的RGB value来划分
<img alt="四叉树二维图" loading="lazy" src="/images/Design_Course_map3__3__3.png"></p>
<p>树结构
<img alt="四叉树树结构" loading="lazy" src="/images/Design_Course_map4_4.png"></p>
<ol>
<li>
<p><strong>QuadTree 类</strong></p>
<ul>
<li>主要负责管理整个四叉树结构：</li>
<li>root: 根节点</li>
<li>leaf_nodes: 所有自由（无障碍物）的叶节点列表</li>
<li>max_depth: 树的最大深度</li>
</ul>
</li>
<li>
<p><strong>QuadTreeNode 类</strong></p>
<ul>
<li>表示四叉树中的单个节点：</li>
<li>values: 节点对应的栅格值(RGB值比如[0,0,0])矩阵</li>
<li>_ru_indices: 节点在原始矩阵中的右上角索引 (i, j)</li>
<li>id_sequence: 节点的ID序列，表示从根到该节点的路径</li>
<li>_neighbors: 节点的邻居 (左, 右, 上, 下)</li>
<li>_children: 子节点列表</li>
<li>state: 节点状态 (FREE, MIX, FULL)</li>
</ul>
</li>
<li>
<p><strong>节点状态</strong>：</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 16, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/hybrid-planner-integration/">为什么以及如何集成四叉树 &#43; MPC &#43; DRL 进行机器人轨迹规划？</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p>在复杂的动态环境中，单一的路径规划或控制策略常常难以兼顾全局最优性与局部可行性。本篇博客介绍一个结合了 <strong>四叉树（QuadTree）+ 模型预测控制（MPC）+ 深度强化学习（DRL）</strong> 的混合轨迹规划框架，该方案的主模块集中在 <code>helper_main_continous.py</code> 文件中，具备良好的模块化与通用性。
<img alt="机器人DRL轨迹图" loading="lazy" src="/images/hybrid_control_result.png"></p>
<h2 id="一模块概览">一、模块概览</h2>
<h3 id="1-地图生成与表示">1. 地图生成与表示</h3>
<ul>
<li><code>generate_map()</code>：支持多场景自动生成地图，包括边界、静态/动态障碍物与目标点。</li>
<li><code>get_geometric_map()</code>：将地图对象转换为可用于膨胀和路径推理的几何结构。</li>
<li><code>Inflator</code> 类：对障碍物轮廓进行 buffer 膨胀，提升安全冗余。</li>
</ul>
<h3 id="2-四叉树路径规划模块">2. 四叉树路径规划模块</h3>
<ul>
<li>由外部函数 <code>create_quadtree_from_occupancy_map()</code> 从栅格占用地图创建四叉树划分空间</li>
<li><code>quadtree_to_mpc_constraints()</code>（外部实现）：提取四叉树路径节点所在区域的凸包，生成可传递给 MPC 的约束区域。</li>
</ul>
<h3 id="3-mpc-控制器接口">3. MPC 控制器接口</h3>
<ul>
<li><code>InterfaceMpc</code>（外部模块）：支持静态/动态障碍物约束注入与轨迹生成。</li>
<li><code>integrate_quadtree_with_mpc()</code>：将自由空间区域和动态障碍一起传入 MPC，生成优化轨迹。</li>
</ul>
<h3 id="4-drl-策略控制">4. DRL 策略控制</h3>
<ul>
<li>控制逻辑中支持调用训练好的 DDPG / TD3 策略模型预测动作。</li>
<li>动作 smoothness 与可行性在 <code>Metrics</code> 中有单独评估指标。</li>
</ul>
<h3 id="5-智能切换模块">5. 智能切换模块</h3>
<ul>
<li><code>HintSwitcher</code>：在 MPC 不再可行或目标区域过于复杂时，切换至 DRL 策略接管。</li>
<li>切换机制基于当前轨迹与障碍物距离，具备滞回机制避免频繁切换。</li>
</ul>
<hr>
<h2 id="二系统整体工作流程">二、系统整体工作流程</h2>
<p>以下代码片段概括了系统的主要运行步骤：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Step 1: 创建地图对象</span>
</span></span><span style="display:flex;"><span>map_data <span style="color:#f92672">=</span> generate_map()
</span></span><span style="display:flex;"><span>mpc_controller <span style="color:#f92672">=</span> InterfaceMpc(map_data)
</span></span><span style="display:flex;"><span>config <span style="color:#f92672">=</span> Configurator()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Step 2: 四叉树路径规划</span>
</span></span><span style="display:flex;"><span>quadtree <span style="color:#f92672">=</span> create_quadtree_from_occupancy_map(occupancy_map)
</span></span><span style="display:flex;"><span>constraints <span style="color:#f92672">=</span> quadtree_to_mpc_constraints(quadtree, current_state, goal_state)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Step 3: MPC 轨迹生成</span>
</span></span><span style="display:flex;"><span>mpc_controller<span style="color:#f92672">.</span>update_static_constraints(constraints)
</span></span><span style="display:flex;"><span>trajectory <span style="color:#f92672">=</span> mpc_controller<span style="color:#f92672">.</span>generate_trajectory(current_state, goal_state)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Step 4: 智能控制切换（DRL or MPC）</span>
</span></span><span style="display:flex;"><span>switcher <span style="color:#f92672">=</span> HintSwitcher(max_switch_distance<span style="color:#f92672">=</span><span style="color:#ae81ff">5.0</span>, min_detach_distance<span style="color:#f92672">=</span><span style="color:#ae81ff">8.0</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> switcher<span style="color:#f92672">.</span>switch(current_position, original_traj, new_traj, obstacle_list):
</span></span><span style="display:flex;"><span>    action <span style="color:#f92672">=</span> drl_model<span style="color:#f92672">.</span>predict(observation)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    action <span style="color:#f92672">=</span> mpc_controller<span style="color:#f92672">.</span>get_control_action()
</span></span></code></pre></div><hr>
<h2 id="三关键函数解读">三、关键函数解读</h2>
<h3 id="quadtree_to_mpc_constraints"><code>quadtree_to_mpc_constraints</code></h3>
<p>将路径所经过的四叉树节点提取对应的多边形凸包作为可通行区域，转换为 MPC 优化器所需的约束形式。</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 7, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/merge_safe_areas/">如何合并多个 Safe Area 以简化规划图结构？</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><hr>
<h2 id="背景为什么要合并-safe-area">背景：为什么要合并 Safe Area？</h2>
<p>在使用 QuadTree 构建环境分区时，每一个 <code>FREE</code> 类型的叶子节点都会生成一个凸包（Convex Hull）作为局部的 Safe Area。但随着环境分辨率提高或障碍物分布稠密，Safe Area 数量可能激增，带来以下问题：</p>
<ul>
<li>路径图节点数量过多，导致 A* 搜索复杂度提升</li>
<li>MPC 控制器的参考轨迹中断多，规划不平滑</li>
<li>可视化和维护困难</li>
</ul>
<p>因此，<strong>将临近的 Safe Area 合并为更大的安全区域</strong> 是简化规划图结构、提高控制性能的重要手段。</p>
<hr>
<h2 id="合并判据设计">合并判据设计</h2>
<p>在 <code>connective_quadtree.py</code> 和 <code>utils_geo.py</code> 中，我们可以基于以下原则实现 Safe Area 合并：</p>
<ol>
<li><strong>邻接性</strong>：两个凸包边界是否接近或重合</li>
<li><strong>几何相容性</strong>：合并后的点集是否仍然可以构成一个有效凸包</li>
<li><strong>面积提升评估</strong>：合并后凸包面积未显著膨胀，避免引入死角区域</li>
</ol>
<p>利用 <code>shapely</code> 和 <code>scipy.spatial.ConvexHull</code>，可以进行合并模拟与几何判断。</p>
<hr>
<h2 id="合并过程实现思路">合并过程实现思路</h2>
<p>合并逻辑可以封装为 <code>merge_safe_areas()</code> 函数，并添加到 <code>QuadTree</code> 类中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">merge_safe_areas</span>(self, distance_threshold<span style="color:#f92672">=</span><span style="color:#ae81ff">2.0</span>):
</span></span><span style="display:flex;"><span>    merged <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    used <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>    keys <span style="color:#f92672">=</span> list(self<span style="color:#f92672">.</span>convex_hulls<span style="color:#f92672">.</span>keys())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(keys)):
</span></span><span style="display:flex;"><span>        id1 <span style="color:#f92672">=</span> keys[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> id1 <span style="color:#f92672">in</span> used: <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        hull1 <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>convex_hulls[id1]
</span></span><span style="display:flex;"><span>        points1 <span style="color:#f92672">=</span> hull1<span style="color:#f92672">.</span>points[hull1<span style="color:#f92672">.</span>vertices]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, len(keys)):
</span></span><span style="display:flex;"><span>            id2 <span style="color:#f92672">=</span> keys[j]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> id2 <span style="color:#f92672">in</span> used: <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            hull2 <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>convex_hulls[id2]
</span></span><span style="display:flex;"><span>            points2 <span style="color:#f92672">=</span> hull2<span style="color:#f92672">.</span>points[hull2<span style="color:#f92672">.</span>vertices]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 判断是否可合并（如边界相近、联合后仍凸）</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> can_merge(points1, points2, distance_threshold):
</span></span><span style="display:flex;"><span>                combined <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>vstack((points1, points2))
</span></span><span style="display:flex;"><span>                new_hull <span style="color:#f92672">=</span> ConvexHull(combined)
</span></span><span style="display:flex;"><span>                merged<span style="color:#f92672">.</span>append(new_hull)
</span></span><span style="display:flex;"><span>                used<span style="color:#f92672">.</span>update([id1, id2])
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>convex_hulls <span style="color:#f92672">=</span> {<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;merged_</span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>: hull <span style="color:#66d9ef">for</span> i, hull <span style="color:#f92672">in</span> enumerate(merged)}
</span></span></code></pre></div><p>其中 <code>can_merge()</code> 可以使用 <code>shapely.Polygon</code> 判断是否相交或几何接近。</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">Apr 17, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/e2e-driving-resnet-lstm/">基于ResNet&#43;LSTM的端到端自动驾驶转向预测</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><h2 id="项目背景">项目背景</h2>
<p>本项目旨在探索如何使用卷积神经网络（ResNet）提取图像空间特征，并结合LSTM对时序依赖进行建模，从而预测车辆在自动驾驶中的转向角度。</p>
<p>此任务属于端到端自动驾驶建模的一部分，重点在于将连续图像帧映射为连续控制输出（方向盘角度）。</p>
<h2 id="模型结构概览">模型结构概览</h2>
<p>整体结构采用两阶段：</p>
<ol>
<li><strong>ResNet 特征提取</strong>：对每帧输入图像进行空间编码,提取每一帧的空间语义信息，如车道线、前车位置等。</li>
<li><strong>LSTM 序列建模</strong>：将序列化的图像特征送入LSTM，实现对短期历史状态的记忆和对当前状态的连续预测,预测未来1~N帧的角度</li>
</ol>
<h2 id="模型结构图">模型结构图</h2>
<p><img alt="模型结构" loading="lazy" src="/images/model_diagram_v2.png"></p>
<h2 id="数据与预处理">数据与预处理</h2>
<p>数据来源为模拟驾驶场景中的中心摄像头图像，标签为方向盘角度。</p>
<ul>
<li>输入帧尺寸统一为 224x224</li>
<li>标签为每帧角度（可选包含扭矩、车速）</li>
<li>图像预处理：resize → normalize → batch</li>
<li>标签标准化：使用均值/方差归一化角度值</li>
<li>损失函数：MSE 均方误差损失</li>
<li>优化器：Adam, 学习率 = 1e-4</li>
<li>序列长度：T = 5（即每个样本为连续5帧）</li>
</ul>
<h2 id="实验结果">实验结果</h2>
<p>在测试集上，MSE 误差为 <strong>0.06</strong>，对应角度误差约为 <strong>7°</strong>。<br>
模型在直线段表现稳定，在连续转弯段有一定预测延迟</p>
<p><img alt="loss_curve" loading="lazy" src="/images/loss_curve.png"></p>
<h2 id="关键代码片段">关键代码片段：</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResNetLSTMModel</span>(nn<span style="color:#f92672">.</span>Module):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__()
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>resnet <span style="color:#f92672">=</span> resnet18(pretrained<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>lstm <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>LSTM(input_size<span style="color:#f92672">=</span><span style="color:#ae81ff">512</span>, hidden_size<span style="color:#f92672">=</span><span style="color:#ae81ff">128</span>, batch_first<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>fc <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Linear(<span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, x_seq):
</span></span><span style="display:flex;"><span>        batch, seq_len, C, H, W <span style="color:#f92672">=</span> x_seq<span style="color:#f92672">.</span>shape
</span></span><span style="display:flex;"><span>        feats <span style="color:#f92672">=</span> [self<span style="color:#f92672">.</span>resnet(x_seq[:, i]) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(seq_len)]
</span></span><span style="display:flex;"><span>        feats <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>stack(feats, dim<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># [B, T, D]</span>
</span></span><span style="display:flex;"><span>        out, _ <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>lstm(feats)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>fc(out[:, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span></code></pre></div><h2 id="模型选择与对比分析">模型选择与对比分析</h2>
<p>为什么选择 ResNet 而不是简单 CNN：</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">Apr 10, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/map-structure-explained/">路径规划（一）几何地图与占用地图在路径规划中的应用</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p>在移动机器人路径规划项目中，地图的表达形式对规划算法的效率与可行性起着决定性作用。本文将介绍两种核心地图结构 —— <code>GeometricMap</code> 与 <code>OccupancyMap</code>，并结合代码逻辑说明它们与四叉树（QuadTree）在路径规划中的协作方式。</p>
<hr>
<h2 id="一occupancymap-占用地图">一、OccupancyMap 占用地图</h2>
<p><code>OccupancyMap</code> 是通过图像（通常是.png地图或实时图像）生成的像素级地图，用于表示每个区域是否可通行。
<img alt="占用地图" loading="lazy" src="/images/Occupancy_grid.png"></p>
<p>占用网格图将空间离散化为任意分辨率的正方形,为每个正方形分配一个二进制值0/1标志被占用或者空闲
<img alt="占用地图" loading="lazy" src="/images/occupancy_grid2.png"></p>
<p>一旦将空间表示为图，就有经典的最短路径图算法可以保证在给定无限的计算时间和资源的情况下找到最短路径。</p>
<h3 id="功能概述">功能概述</h3>
<ul>
<li>接收一张地图图像 <code>map_image</code>，支持 RGB 或灰度图；</li>
<li>将图像转为灰度图后，基于 <code>occupancy_threshold</code> 生成二值图（黑=障碍，白=可通行）；
<img alt="occupancygridmap" loading="lazy" src="/images/grid_map_visualization.png"></li>
</ul>
<p><img alt="二值图" loading="lazy" src="/images/grid_map.png"></p>
<ul>
<li>可返回背景图、灰度图或二值图；</li>
<li>支持从图像提取边界与障碍的几何信息（返回 <code>boundary_coords</code> 和 <code>obstacle_list</code>）。
<img alt="边界提取" loading="lazy" src="/images/map_visualization.png"></li>
</ul>
<h3 id="典型代码片段">典型代码片段</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>occupancy_map <span style="color:#f92672">=</span> OccupancyMap(map_image)
</span></span><span style="display:flex;"><span>boundary_coords, obstacle_list <span style="color:#f92672">=</span> occupancy_map<span style="color:#f92672">.</span>get_geometric_map()
</span></span></code></pre></div><h3 id="在项目中的作用">在项目中的作用</h3>
<ul>
<li>提供最原始的环境表达方式</li>
<li>可以作为输入转为 <code>GeometricMap</code></li>
<li>支持动态更新：如结合摄像头识别障碍，实时构建地图</li>
</ul>
<hr>
<h2 id="二geometricmap-几何地图">二、GeometricMap 几何地图</h2>
<p><code>GeometricMap</code> 用于几何表达方式表示边界和障碍，以便生成高精度的导航地图（用于后续凸包、安全走廊、参考路径的构建）。</p>
<h3 id="geometricmap-是几何表达形式的地图用于">GeometricMap 是“几何表达形式的地图”，用于：</h3>
<table>
  <thead>
      <tr>
          <th>元素</th>
          <th>表示内容</th>
          <th>示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>boundary</code></td>
          <td>整个地图的边界轮廓</td>
          <td>外围矩形 / 不规则多边形</td>
      </tr>
      <tr>
          <td><code>obstacles</code></td>
          <td>障碍物的几何形状</td>
          <td>车、箱子、墙，表示为多边形</td>
      </tr>
      <tr>
          <td><code>inflator</code>（可选）</td>
          <td>将障碍物形状向外膨胀</td>
          <td>提供安全冗余</td>
      </tr>
  </tbody>
</table>
<h3 id="它不是图像地图而是-多边形表达的结构地图">它不是图像地图，而是 <strong>多边形表达的结构地图</strong></h3>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>boundary <span style="color:#f92672">=</span> [(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>), (<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">0</span>), (<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>), (<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">10</span>)]
</span></span><span style="display:flex;"><span>obstacle_list <span style="color:#f92672">=</span> [[(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>)]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>map <span style="color:#f92672">=</span> GeometricMap(boundary, obstacle_list)
</span></span></code></pre></div><p>这里就表达了一个 10x10 的区域，里面有一个 1x1 的方形障碍物。</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">Dec 15, 2024</span>
  </footer>
</article>

        
      </div>
    
      <h2 style="margin-top: 2rem;">DRL</h2>
      <div class="post-list">
        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/drl-algorithm-comparison/">DRL 常见算法对比</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><hr>
<p>深度强化学习（Deep RL）发展出多个主流算法流派，包括基于值函数的 DQN、基于策略梯度的 REINFORCE/PPO，以及融合策略和值函数的 Actor-Critic 框架（如 A2C、DDPG、SAC）。每种方法适用于不同场景，选择合适算法将显著影响模型性能与训练效率。</p>
<hr>
<h2 id="三大算法流派对比">三大算法流派对比</h2>
<table>
  <thead>
      <tr>
          <th>算法类型</th>
          <th>特点</th>
          <th>优点</th>
          <th>局限</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Value-based</td>
          <td>学习 Q(s, a) 并通过贪婪策略选动作</td>
          <td>样本利用率高，适合离散动作空间</td>
          <td>不适用于连续/高维动作</td>
          <td></td>
      </tr>
      <tr>
          <td>Policy-based</td>
          <td>直接建模并优化策略 π(a</td>
          <td>s)</td>
          <td>适合连续动作，训练稳定</td>
          <td>样本效率低，梯度方差大</td>
      </tr>
      <tr>
          <td>Actor-Critic</td>
          <td>同时训练策略和价值函数</td>
          <td>综合两者优势，适用于复杂控制问题</td>
          <td>架构复杂，对超参数敏感</td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="一dqndeep-q-network">一、DQN（Deep Q-Network）</h2>
<p><strong>类型</strong>：Value-based</p>
<p><strong>损失函数（均方 TD 误差）</strong>：</p>
<blockquote>
<p>L(θ) = 𝔼ₜ [(rₜ + γ · maxₐ′ Qθ⁻(sₜ₊₁, a′) − Qθ(sₜ, aₜ))²]</p></blockquote>
<p>其中：</p>
<ul>
<li>θ 是 Q 网络参数</li>
<li>θ⁻ 是目标网络参数（定期同步）</li>
<li>使用贪婪策略选择 <code>a′ = argmax Q(s′, a′)</code></li>
</ul>
<p><strong>优化器</strong>：Adam 或 SGD，通过反向传播最小化 TD 误差更新 θ。</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 17, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/how-to-train-drl-model/">DRL训练</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p>在深度强化学习（Deep Reinforcement Learning）中，我们的目标是：训练一个智能体（Agent），使其能够在复杂环境中通过交互、试错和学习，掌握解决任务的策略。</p>
<p>整个训练流程不是一行 <code>.fit()</code> 就能完成的，它涉及数据采集、策略评估、价值估计、梯度优化等多个协同模块。本文将逐步介绍训练所需的关键模块和完整流程。</p>
<hr>
<h2 id="drl-训练流程的核心结构">DRL 训练流程的核心结构</h2>
<p>一个标准的 DRL 系统至少包括以下几个部分：</p>
<h3 id="1-环境environment">1. 环境（Environment）</h3>
<ul>
<li>提供 <code>reset()</code> 和 <code>step(action)</code> 接口</li>
<li>返回状态、奖励、终止信号和调试信息</li>
<li>通常使用 Gymnasium 编写，也可以是仿真器（如 PyBullet、AirSim）或实际系统接口</li>
</ul>
<h3 id="2-策略网络policy-network">2. 策略网络（Policy Network）</h3>
<ul>
<li>输入当前状态，输出一个动作（或动作分布）</li>
<li>对于离散动作空间，常见输出为 softmax 分布；连续动作空间则直接输出浮点数</li>
<li>通常是 MLP（结构化输入）或 CNN（图像输入）网络</li>
</ul>
<h3 id="3-值函数网络critic-可选">3. 值函数网络（Critic, 可选）</h3>
<ul>
<li>用于评估当前策略下某状态的“好坏”，即状态值 V(s) 或动作值 Q(s,a)</li>
<li>在 Actor-Critic 架构中，Actor 提出动作，Critic 提供反馈</li>
</ul>
<h3 id="4-回放缓存replay-buffer">4. 回放缓存（Replay Buffer）</h3>
<ul>
<li>保存经验 <code>(state, action, reward, next_state, done)</code></li>
<li>支持随机采样，避免训练中数据高度相关</li>
<li>对于 off-policy 算法（如 DDPG、TD3）是必要组件</li>
</ul>
<h3 id="5-优化器与更新规则optimizer">5. 优化器与更新规则（Optimizer）</h3>
<ul>
<li>根据策略梯度、TD 误差、KL 散度等损失函数对网络参数进行更新</li>
<li>通常使用 Adam 优化器</li>
</ul>
<hr>
<h2 id="强化学习算法的三种主流架构">强化学习算法的三种主流架构</h2>
<table>
  <thead>
      <tr>
          <th>方法类别</th>
          <th>特点</th>
          <th>代表算法</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Policy-based</td>
          <td>直接建模并优化策略 π(a,s)，通过最大化期望回报更新策略</td>
          <td>REINFORCE, PPO, TRPO</td>
          <td></td>
      </tr>
      <tr>
          <td>Value-based</td>
          <td>学习动作价值函数 Q(s,a)，通过贪婪策略导出动作选择</td>
          <td>DQN, Double DQN, Dueling DQN</td>
          <td></td>
      </tr>
      <tr>
          <td>Actor-Critic</td>
          <td>同时学习策略和价值函数，策略用于决策，价值函数用于评估</td>
          <td>A2C, A3C, DDPG, TD3, SAC, PPO</td>
          <td></td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong>Policy-based</strong> 方法训练稳定性强、适合高维动作空间，但样本效率较低。</li>
<li><strong>Value-based</strong> 方法样本效率较高，适用于离散动作任务，但连续控制较困难。</li>
<li><strong>Actor-Critic</strong> 综合两者优势，是当前主流算法的主干框架。</li>
</ul>
<hr>
<h2 id="一个完整训练循环的结构">一个完整训练循环的结构</h2>
<p>以下是一个 off-policy 强化学习算法（如 DDPG）的大致流程：</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 2, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/what-is-gymnasium/">强化学习环境之 Gymnasium</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p><code>Gymnasium</code> 是 Python 中一个标准化的强化学习环境库（它是原始 <code>OpenAI Gym</code> 的升级版）。它的作用是：</p>
<blockquote>
<p>把复杂问题（如机器人走路、自驾车避障）包装成统一的“游戏接口”，让强化学习模型可以跟它反复互动、学会做决策。</p></blockquote>
<p>换句话说，它是一个统一标准，让算法和环境能“说上话”。只要环境符合 Gymnasium 接口，你就能直接套用主流算法如 PPO、DDPG、DQN 去训练。</p>
<hr>
<h2 id="如何安装-gymnasium">如何安装 Gymnasium？</h2>
<p>在终端输入以下命令安装（建议使用虚拟环境）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pip install gymnasium<span style="color:#f92672">[</span>all<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>如果你只用基本环境，不包括 Atari、Box2D 等，可以简化为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pip install gymnasium
</span></span></code></pre></div><hr>
<h2 id="在代码中如何导入并使用">在代码中如何导入并使用</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> gymnasium <span style="color:#66d9ef">as</span> gym
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>env <span style="color:#f92672">=</span> gym<span style="color:#f92672">.</span>make(<span style="color:#e6db74">&#34;CartPole-v1&#34;</span>)
</span></span><span style="display:flex;"><span>obs, info <span style="color:#f92672">=</span> env<span style="color:#f92672">.</span>reset()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    action <span style="color:#f92672">=</span> env<span style="color:#f92672">.</span>action_space<span style="color:#f92672">.</span>sample()  <span style="color:#75715e"># 随机动作（一般训练中由模型决定）</span>
</span></span><span style="display:flex;"><span>    obs, reward, terminated, truncated, info <span style="color:#f92672">=</span> env<span style="color:#f92672">.</span>step(action)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> terminated <span style="color:#f92672">or</span> truncated:
</span></span><span style="display:flex;"><span>        obs, info <span style="color:#f92672">=</span> env<span style="color:#f92672">.</span>reset()
</span></span></code></pre></div><p>这段代码展示了标准的强化学习交互流程：</p>
<ol>
<li>初始化环境（<code>reset()</code>）</li>
<li>持续循环：选择动作 → 执行动作 → 接收反馈</li>
</ol>
<hr>
<h2 id="环境的输入与输出env-接口结构">环境的输入与输出：Env 接口结构</h2>
<h3 id="输入action">输入：action</h3>
<p>你给环境的输入是一个“动作”，比如：</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">Dec 17, 2024</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/ros%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/">如何使用 C&#43;&#43; 编写一个 ROS 节点</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p>通过本案例可以掌握：</p>
<ul>
<li>如何使用 C++ 编写一个 ROS 设备驱动节点；</li>
<li>如何调试 ROS 发布频率、时间戳和消息内容；</li>
<li>如何结合 rosbag 与 rqt_plot 分析传感器数据的稳定性；</li>
<li>为后续多传感器时间同步与融合（如 EKF）打下基础。</li>
</ul>
<h1 id="多传感器融合中的-ros-驱动开发实战案例">多传感器融合中的 ROS 驱动开发实战案例</h1>
<p>在自动驾驶系统中，IMU、GNSS 和雷达等传感器是实现环境感知和车辆定位的关键。本文以 ROS 框架为基础，讲解如何编写一个简单的传感器驱动节点，实现数据采集 → 解析 → 发布 → 可视化，并附带常见调试命令。</p>
<hr>
<h2 id="1-项目结构">1. 项目结构</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>my_sensor_driver/
</span></span><span style="display:flex;"><span>├── launch/
</span></span><span style="display:flex;"><span>│   └── sensor_driver.launch
</span></span><span style="display:flex;"><span>├── src/
</span></span><span style="display:flex;"><span>│   └── imu_driver_node.cpp
</span></span><span style="display:flex;"><span>├── include/
</span></span><span style="display:flex;"><span>│   └── imu_driver.hpp
</span></span><span style="display:flex;"><span>├── config/
</span></span><span style="display:flex;"><span>│   └── imu_config.yaml
</span></span><span style="display:flex;"><span>├── CMakeLists.txt
</span></span><span style="display:flex;"><span>├── package.xml
</span></span></code></pre></div><ul>
<li>
<p>my_sensor_driver： ROS package 根目录，所有内容都放在这里</p>
</li>
<li>
<p>launch/sensor_driver.launch：</p>
<ul>
<li>ROS 的启动脚本，用 XML 格式描述：
<ul>
<li>启动哪个节点（node）</li>
<li>使用哪些参数文件（如 config/imu_config.yaml）</li>
<li>是否输出日志到屏幕等</li>
<li>用法：<strong>roslaunch my_sensor_driver sensor_driver.launch</strong></li>
<li>示例：</li>
</ul>
<pre tabindex="0"><code class="language-launch" data-lang="launch">&lt;launch&gt;
&lt;!-- 加载 IMU 参数配置 --&gt;
&lt;rosparam file=&#34;$(find my_sensor_driver)/config/imu_config.yaml&#34; command=&#34;load&#34;/&gt;

&lt;!-- 启动 IMU 驱动节点 --&gt;
&lt;node name=&#34;imu_driver&#34; pkg=&#34;my_sensor_driver&#34; type=&#34;imu_driver_node&#34; output=&#34;screen&#34;/&gt;
&lt;/launch&gt;
</code></pre></li>
</ul>
</li>
<li>
<p>src/imu_driver_node.cpp</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">Nov 17, 2024</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/state-action-space/">强化学习的状态空间和动作空间是什么</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p>在强化学习中，状态空间（Observation Space）和动作空间（Action Space）是两个基础概念。理解这两个空间，就等于弄清楚“模型看到了什么”和“模型可以做什么”。</p>
<p>在本项目中，我们使用的是基于图像和传感器输入的强化学习模型，用于端到端的控制任务，如预测方向、速度或操作行为。下面我们从通用概念讲起，最后具体说明本项目的定义。</p>
<hr>
<h2 id="状态空间observation-space">状态空间（Observation Space）</h2>
<p>状态空间描述了智能体每一步能从环境中获取到的“状态信息”。这些信息构成了模型的输入，可以是一个向量，也可以是图像、组合信号等。</p>
<h3 id="常见类型">常见类型：</h3>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>示例</th>
          <th>含义说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>Box(4,)</code></td>
          <td><code>[-4.8, 4.8]</code> × 4</td>
          <td>连续变量向量，如位置、速度等</td>
      </tr>
      <tr>
          <td><code>Box(84, 84, 3)</code></td>
          <td>图像输入</td>
          <td>视觉输入，常用于端到端控制</td>
      </tr>
      <tr>
          <td><code>Dict(...)</code></td>
          <td>多通道输入</td>
          <td>图像 + 雷达 + IMU 组合观测</td>
      </tr>
  </tbody>
</table>
<h3 id="本项目中的状态空间定义">本项目中的状态空间定义：</h3>
<p>在本项目中，我们的状态空间通常包括：</p>
<ul>
<li><strong>图像帧</strong>：从机器人前置摄像头获取的 RGB 图像（如 <code>(224, 224, 3)</code>）</li>
<li><strong>附加状态向量</strong>（可选）：如上一帧速度、转角、航向角等传感器读数</li>
</ul>
<p>状态空间结构可能是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Box(low<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, high<span style="color:#f92672">=</span><span style="color:#ae81ff">255</span>, shape<span style="color:#f92672">=</span>(<span style="color:#ae81ff">224</span>, <span style="color:#ae81ff">224</span>, <span style="color:#ae81ff">3</span>), dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>uint8)
</span></span></code></pre></div><p>或</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Dict({
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;image&#34;</span>: Box(<span style="color:#f92672">...</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;speed&#34;</span>: Box(<span style="color:#f92672">...</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;yaw&#34;</span>: Box(<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><hr>
<h2 id="动作空间action-space">动作空间（Action Space）</h2>
<p>动作空间描述了模型每一步可以采取的动作范围，也就是输出的结构。</p>
<h3 id="常见类型-1">常见类型：</h3>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>示例</th>
          <th>用途说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>Discrete(n)</code></td>
          <td><code>Discrete(3)</code></td>
          <td>离散控制，如左、右、直行</td>
      </tr>
      <tr>
          <td><code>Box(...)</code></td>
          <td><code>Box(-1, 1, (2,), float32)</code></td>
          <td>连续动作，如转角和加速度控制</td>
      </tr>
      <tr>
          <td><code>MultiBinary(n)</code></td>
          <td><code>MultiBinary(5)</code></td>
          <td>多位二进制开关组合</td>
      </tr>
  </tbody>
</table>
<h3 id="本项目中的动作空间定义">本项目中的动作空间定义：</h3>
<p>我们通常使用连续动作空间来控制机器人，例如：</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">Nov 17, 2024</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/data_structure_and_algorithm/">数据结构与算法(自动驾驶应用方向)</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><h1 id="数据结构与算法自动驾驶应用方向">数据结构与算法（自动驾驶应用方向）</h1>
<p>在自动驾驶中，无论是路径规划、障碍物识别，还是实时控制，都离不开对<strong>数据的高效组织和计算方法的选择</strong>。</p>
<hr>
<h2 id="2-常见数据结构及自动驾驶应用">2. 常见数据结构（及自动驾驶应用）</h2>
<table>
  <thead>
      <tr>
          <th>数据结构</th>
          <th>描述</th>
          <th>应用示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>数组 / 向量</strong></td>
          <td>连续存储，支持随机访问</td>
          <td>储存历史轨迹点、车辆状态序列</td>
      </tr>
      <tr>
          <td><strong>链表 / 环形队列</strong></td>
          <td>灵活插入/删除</td>
          <td>控制器中缓存最近速度或传感器数据</td>
      </tr>
      <tr>
          <td><strong>栈 / 队列</strong></td>
          <td>先进后出 / 先进先出</td>
          <td>控制状态切换、命令排队处理</td>
      </tr>
      <tr>
          <td><strong>哈希表（Hash Map）</strong></td>
          <td>快速查找</td>
          <td>建图中障碍物记录，传感器缓存索引</td>
      </tr>
      <tr>
          <td><strong>堆（Heap）</strong></td>
          <td>优先级队列</td>
          <td>A*/Dijkstra路径搜索中寻找最短路径</td>
      </tr>
      <tr>
          <td><strong>树 / 四叉树 / 八叉树</strong></td>
          <td>分层组织空间</td>
          <td>空间分割（如QuadTree用于2D路径规划）</td>
      </tr>
      <tr>
          <td><strong>图（Graph）</strong></td>
          <td>节点+边</td>
          <td>路径规划地图、任务依赖图等</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="3-算法在自动驾驶中的典型应用">3. 算法在自动驾驶中的典型应用</h2>
<h3 id="31-搜索与路径规划算法">3.1 搜索与路径规划算法</h3>
<table>
  <thead>
      <tr>
          <th>算法</th>
          <th>应用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>A*</strong></td>
          <td>地图中的最短路径搜索</td>
      </tr>
      <tr>
          <td><strong>Dijkstra</strong></td>
          <td>全局路径规划</td>
      </tr>
      <tr>
          <td><strong>RRT/RRT*</strong></td>
          <td>采样路径规划，适用于复杂动态场景</td>
      </tr>
  </tbody>
</table>
<h3 id="32-数学优化类算法">3.2 数学优化类算法</h3>
<table>
  <thead>
      <tr>
          <th>算法</th>
          <th>应用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>MPC（Model Predictive Control）</strong></td>
          <td>控制指令生成，预测未来行为</td>
      </tr>
      <tr>
          <td><strong>最小均方（LMS）/最小二乘（LS）</strong></td>
          <td>滤波器设计，状态估计等</td>
      </tr>
  </tbody>
</table>
<h3 id="33-搜索结构加速">3.3 搜索结构加速</h3>
<table>
  <thead>
      <tr>
          <th>技术</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>KD-Tree</td>
          <td>快速搜索最近邻（如点云比对）</td>
      </tr>
      <tr>
          <td>Hashing</td>
          <td>快速定位地图块、路段编号</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="-4-示例a-路径规划伪代码">🧪 4. 示例：A* 路径规划（伪代码）</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">A_star</span>(start, goal, map):
</span></span><span style="display:flex;"><span>    open_list <span style="color:#f92672">=</span> PriorityQueue()
</span></span><span style="display:flex;"><span>    open_list<span style="color:#f92672">.</span>put(start)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> open_list<span style="color:#f92672">.</span>empty():
</span></span><span style="display:flex;"><span>        current <span style="color:#f92672">=</span> open_list<span style="color:#f92672">.</span>get()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> current <span style="color:#f92672">==</span> goal:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> reconstruct_path()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> neighbor <span style="color:#f92672">in</span> get_neighbors(current):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> visited(neighbor):
</span></span><span style="display:flex;"><span>                cost <span style="color:#f92672">=</span> calculate_cost(current, neighbor)
</span></span><span style="display:flex;"><span>                open_list<span style="color:#f92672">.</span>put(neighbor, cost)
</span></span></code></pre></div><hr>
<h2 id="-推荐学习资料">📘 推荐学习资料</h2>
<ul>
<li>《算法图解》：通俗易懂的入门书</li>
<li>《数据结构与算法分析》：理论+实现</li>
<li>LeetCode 专题：图、堆、树、搜索优化</li>
<li>ROS Navigation Stack 源码分析</li>
</ul></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 2, 2024</span>
  </footer>
</article>

        
      </div>
    
      <h2 style="margin-top: 2rem;">Product &amp; Project Management</h2>
      <div class="post-list">
        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/%E5%9F%8E%E5%B8%82noa%E7%AB%9E%E5%93%81%E6%8A%80%E6%9C%AF%E5%85%A8%E6%99%AF%E4%B8%8A%E4%BB%8Ebev%E5%88%B0vla%E6%8B%86%E8%A7%A3%E7%90%86%E6%83%B3%E5%B0%8F%E9%B9%8F%E8%94%9A%E6%9D%A5%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%B0%B4%E5%B2%AD/">城市NOA功能竞品分析</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p>理想、小鹏、蔚来的</p>
<h1 id="城市noa技术战局上从bev到vla拆解头部玩家技术路线">城市NOA技术战局（上）：从BEV到VLA，拆解头部玩家技术路线</h1>
<p><strong>主要结论：</strong></p>
<p>继2023–2024年BEV+Transformer+Occupancy Network架构成为智能驾驶的感知主流后，2025年起，行业正加速向更高级的**VLM（Vision-Language Model）<strong>与</strong>VLA（Vision-Language-Action）**模型演进。相较于传统BEV结构仅关注空间几何关系，VLM/VLA引入语言推理模块，可对标志、规则、指令进行语义理解，结合多模态输入（如摄像头图像、语音交互、交通文本信息），生成更泛化、更类人的行为决策。</p>
<p>芯片与算力能力成为支撑城市NOA架构升级的关键基础。2020年前后主流平台算力集中于144 TOPS，如今已普遍跃升至500 TOPS以上，高端平台如蔚来NX9031、理想Thor-U、小鹏图灵AI芯片等更达到千级算力，支撑端到端推理、大模型部署与多模态处理。自研芯片、自建智算中心、自主模型训练正成为具备战略自主能力车企的核心壁垒。</p>
<p>在感知侧，“视觉为主+激光雷达补盲”已成为当前主流配置。视觉方案具备数据规模与算力适配优势，激光雷达则增强空间精度与安全冗余，尤其在无高精地图场景中具备更强稳定性。不同厂商依据策略选择单感知或多模态融合方案，构建安全容错体系。</p>
<ol>
<li><strong>产品背景</strong></li>
</ol>
<p>近年来，随着特斯拉AutoPilot不断进阶至FSD，辅助驾驶已从L0级定速巡航，逐步拓展至高速NOA，再迈入城市NOA阶段，覆盖更复杂多变的交通环境。智能驾驶正在从“技术亮点”转向“核心卖点”，显著影响消费者购车决策。</p>
<p>以小鹏和问界为例：小鹏G6智驾版配置占比超过70%，问界新M7的大定用户中也有60%以上选择搭载高阶智能驾驶方案。这一趋势标志着，中国智能驾驶市场已全面进入L2+/NOA功能的规模化普及阶段。</p>
<p>L2+辅助驾驶能力包括自适应巡航（ACC）、车道居中控制（LCC）、自动变道（ALC）、高速NOA等，城市NOA则在此基础上，扩展至非结构化路况中的红绿灯通行、环岛绕行、路口博弈等复杂决策工况，对感知精度、决策智能与系统泛化能力提出更高要求。</p>
<p>在城市NOA推进过程中，<strong>高精地图鲜度不足、覆盖受限、成本高昂等问题，成为核心瓶颈</strong>。为突破此限制，主流技术路线正在从依赖地图的规则驱动方案，全面转向<strong>端到端模型驱动 + 自主环境建图 + 多模态策略融合</strong>的新范式。</p>
<p>技术架构上，感知模块经历了从前向2D视角 → BEV建图 → Occupancy Network建模的迭代，决策控制模块也正由传统rule-based状态机，向<strong>基于神经网络的端到端行为预测</strong>发展。2025年起，VLM（视觉语言模型）和VLA（Vision-Language-Action）架构逐步上车，赋予系统语义理解与策略推理能力，成为当前算法演进的前沿方向。</p>
<p>本报告将围绕特斯拉、小鹏、理想、蔚来等具备自研能力的头部品牌，梳理其城市NOA技术路线演进路径，结合软硬件系统方案与市场落地节奏，探讨中国品牌如何在“从BEV到VLA”的产业跃迁中建立领先优势。</p>
<ol start="2">
<li><strong>目标用户与使用场景</strong></li>
</ol>
<p>L2/L2+辅助驾驶系统主要面向具备一定驾驶经验、希望在日常通勤或长途驾驶中降低疲劳、提升安全性的新能源车主及购车潜在用户。</p>
<p>这类用户普遍关注两个关键问题：</p>
<p>各品牌城市NOA在不同城市、路况下的表现差异；</p>
<p>智驾能力与整车价格之间的性价比。</p>
<p>智能驾驶的核心价值在于：在用户监管下，系统能够预判潜在风险、辅助完成复杂驾驶动作，从而减轻认知负担、降低事故风险。尤其在城市NOA场景中，系统需完成红绿灯识别、路口博弈、避让行人、自主换道等行为，对系统泛化能力、策略鲁棒性和人机交互体验提出更高要求。</p>
<p>因此，城市NOA不仅是“功能拓展”，更代表了整车系统智能化水平的“天花板”。</p>
<ol start="3">
<li><strong>竞品分析</strong></li>
</ol>
<p>本篇章节主要对于特斯拉，以蔚来理想小鹏为代表的头部企业在“城市导航辅助驾驶功能”的进展上进行对比分析，除此之外还包括，硬件系统方案，软件算法，功能配置，交互逻辑，运营方案，亮点场景等对比。</p>
<p><strong>3.1 调研洞察摘要</strong></p>
<p>城市NOA的落地，标志着行业正从规则驱动向数据驱动、从模块化架构向端到端大模型架构转变。以下趋势尤为明显：</p>
<p><strong>技术架构趋同：</strong> 特斯拉、小鹏、蔚来等主流厂商均采用BEV+Transformer+Occupancy Network感知结构，逐步引入端到端神经网络控制器替代传统状态机，提升整体智驾稳定性。</p>
<p><strong>算力平台升级：</strong> 主流平台从原先144TOPS提升至500–1000TOPS以上，大算力平台成为支持端到端大模型部署的基础设施。</p>
<p><strong>数据闭环能力强化：</strong> 具备自动采集、筛选、标注、仿真重建与在线训练能力的“数据-模型-闭环”体系，成为城市NOA性能提升的核心引擎。</p>
<p><strong>用户体验导向增强：</strong> 城市NOA正加速从试点区域向全国多城落地，主机厂纷纷围绕“全国都能开、用户真愿用”目标，推动功能迭代与大模型泛化能力提升。</p>
<p>结论：<strong>在城市NOA成为新一代智能驾驶标配的背景下，能否构建“低成本、高泛化、大闭环”的自研体系，将成为厂商能否突围的核心分水岭。</strong></p>
<p><strong>3.2 技术方案演进与“去高精地图化”</strong></p>
<p>高速NOA因场景结构稳定，长期采用规则驱动+高精地图方式实现；而城市NOA因存在海量动态变量与非结构化场景，传统Rule-based方案难以覆盖，<strong>技术路线普遍演进为以下三个阶段：</strong></p>
<p><strong>基于高精地图的三段式结构：</strong> 感知–规划–控制，依赖静态地图与有限状态机；</p>
<p><strong>BEV+Transformer感知融合结构：</strong> 引入Occupancy Network构建3D空间占据图，提升遮挡处理与障碍识别能力；</p>
<p><strong>端到端 + 多模态语义推理架构（VLA）：</strong> 引入视觉语言模型、扩散策略网络、博弈推理模块等，实现感知–理解–决策一体化。</p>
<p>“去高精地图化”已成为城市NOA发展的行业共识，各家方案通过Occupancy Network、弱地图辅助、分布式建图等方式逐步替代静态地图依赖，以提升系统泛化能力与落地效率。</p>
<p><strong>3.2.1 特斯拉技术演进：</strong></p>
<p><img loading="lazy" src="/images/NOA_image1.png"></p>
<p>自2014年发布AutoPilot 1.0以来，特斯拉持续引领辅助驾驶从规则驱动走向数据驱动、再走向端到端神经控制的范式演进。</p>
<p><strong>HW1.0 + Mobileye平台（2014–2016）：</strong> 初代AutoPilot基于Mobileye方案，支持基本的巡航与车道保持功能，但受限于单摄像头配置与规则逻辑，系统泛化能力有限。</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">Jul 23, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/%E6%B1%BD%E8%BD%A6%E8%A1%8C%E4%B8%9A%E6%99%BA%E8%83%BD%E5%8C%96%E4%B8%8B%E5%8D%8A%E5%9C%BA%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%E7%9A%84%E8%87%AA%E7%A0%94%E8%B6%8B%E5%8A%BF%E4%BB%A5%E5%8F%8A%E4%BA%A7%E5%93%81%E5%8A%9B%E8%B7%83%E8%BF%81/">AI汽车、自研底座与产品力跃迁</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p><strong>汽车行业智能化下半场：人工智能时代的自研趋势以及产品力跃迁</strong></p>
<p>本报告基于对当前中国主流智能车企技术路径的梳理，重点聚焦AI时代自研趋势、技术栈重构与用户体验跃迁路径，提出自研芯片+操作系统在产品竞争力打造中的关键价值。</p>
<p><strong>一、引言：智能驾驶竞争进入“底层能力为王”阶段</strong></p>
<p>随着智能驾驶算法从传统的三段式架构逐步演化为统一大模型，底层算力的压力正在指数级上升。过去由规则驱动的架构，正逐步让位于数据驱动与模型推理为主导的新范式。小鹏、理想都曾表明目标是成为面向全球的AI汽车公司（<a href="https://wallstreetcn.com/articles/3738111">小鹏想成为面向全球的AI汽车公司</a>，<a href="https://stcn.com/article/detail/1468633.html">李想“隐退”九个月后高调发声，要将理想汽车打造成AI公司</a>）， 在这种趋势下，AI三要素中的<strong>数据和算力</strong>，不再是支持角色，而正在成为影响智驾系统架构、决策能力和推理效率的“底层决定性资源”。</p>
<p>以智能驾驶主控芯片为例，从2019年Mobileye EyeQ4的24 TOPS算力，到2023年NVIDIA Orin-X单颗256 TOPS，算力提升10倍以上，芯片价格和适配难度也随之飙升。公开数据显示，Orin-X 零售单价接近 500 美元，在算法开发完成后仍需4~6个月进行底层适配与算子调优。芯片不再是“模块化采购”的一环，而是演化为算法性能释放的“主控变量”。</p>
<p>回顾历史，从智能手机厂商（如苹果、三星以及华为）到云厂商（如亚马逊、谷歌），都经历了<strong>通过自研芯片实现性能边界控制、系统主导权和成本结构优化，自研芯片已成为“技术驱动产品体验”的底层共识。</strong></p>
<p>面对这一演进趋势，蔚小理纷纷加速芯片自研布局，希望打通“自研算法+定制芯片”的协同链条。在这条路径上，在国内厂商中，华为无疑走在更前一步——其MDC系列芯片已在极狐、阿维塔等平台落地，与ADS系统形成“芯片即平台”的整合模式。</p>
<p>自研（智驾/座舱）芯片不仅提高了算力上限，降低了整车成本，同时让企业掌握底层算力与接口设计的主动权，从而决定了智驾域和座舱域<strong>从芯片架构、操作系统、通信协议到电子电器架构</strong>等多个层级的自主可控程度。这些系统共同决定了智能驾驶系统的处理能力、响应速度、功能复用率和可持续升级能力。</p>
<p>这一趋势正是推动智驾系统从“功能运营型”向“技术驱动型”转变的关键分水岭——决定其是跟随迭代，还是主导演进。</p>
<p>但这场底层变革之战的真正价值，或许并不止于技术领先本身，而在于它能否带来一种“自我定义产品体验、构建自驱闭环”的能力边界重塑。<strong>自研芯片+自研架构+OS 作为企业软硬结合的锚点，其作用机制、投入路径与演进节奏，也因此成为观察智能车产业未来格局演化的关键切口</strong>。</p>
<p>本文将聚焦华为与小鹏两家典型代表，从技术栈演化、系统能力建构、用户体验反馈、品牌市场影响等多个维度展开分析，尝试还原自研芯片与操作系统背后，技术战略与产品能力之间的真实因果链条。</p>
<hr>
<p><strong>二、以华为为例，解读OS+MDC+集中式架构带来的体验跃迁</strong></p>
<p>MDC计算平台作为算力支撑，鸿蒙OS构建生态加强交互体验，集中式架构降低系统时延提升智驾功能表现。</p>
<p><strong>2.2 华为 MDC 智能驾驶计算平台—自2018年起持续演进</strong></p>
<p><strong>规划与产品矩阵完善（2018–2021）</strong></p>
<p>2018年3月，华为推出首款MDC智能驾驶计算平台，最初基于<strong>昇腾310芯片</strong>，迄今已发展出包括<strong>MDC210、300F、610、810、Pro 610等</strong>产品，覆盖从L2到L4的不同自动驾驶级别。2024年，搭载MDC610的车型可升级到ADS 3.0，为高阶城市NOA提供了算力基础。</p>
<p><strong>更高算力平台到位（2021–2023）</strong></p>
<p>随后推出的<strong>MDC810</strong>以稠密算力峰值超400 TOPS，支持更复杂的多传感器融合与高精度感知，为L3前装落地铺设平台基础。</p>
<p><strong>最新演进方向：MDC Pro 610系列</strong></p>
<p>截至2025年，华为MDC产品线已新增<strong>MDC Pro 610</strong>等型号，搭载更高算力的昇腾610芯片，并采用12位LPDDR5+液冷散热方案，实现<strong>500–800+ TOPS算力</strong>与更高能效密度。华为 MDC Pro 610 智能驾驶控制器主要用于执行融合、识别、分类任务，同时处理地图定位，以进行路径规划和驾驶决策，从而实现车辆的精确控制和自动驾驶。</p>
<p><strong>2.3 麒麟芯片追赶高通地位，搭配鸿蒙OS，提升智能座舱交互体验</strong></p>
<p>在智能汽车逐步迈入“全栈自研”的时代，操作系统作为底层能力承上启下，是实现<strong>软件解耦、整车协同和体验跃迁</strong>的核心基座。华为率先部署三层操作系统体系——<strong>HarmonyOS OS（座舱）+ AOS（车控）+ VOS（智驾）</strong>，不仅实现了智舱、智驾、车控的能力分离与协同调度，更通过操作系统的持续演进，显著提升整车的流畅性、智能性与安全性体验。</p>
<p><strong>HarmonyOS：从“操作系统”到“生态系统”，提升人车交互体验</strong></p>
<blockquote>
<p>作为车载鸿蒙的重要落地形态，HarmonyOS 不仅承担座舱控制任务，更整合手机、平板、手表、家居IoT等跨终端生态能力，打造“万物互联”的空间体验：</p></blockquote>
<p>分布式架构打造跨终端无缝协同体验，支持多设备间无缝流转（导航、通话、视频会议、音乐等）；</p>
<p>语音助手基于端云协同大模型能力升级（如方舟语音大模型），具备更高意图理解力和情境感知；</p>
<p><strong>界面响应与流畅性极大提升</strong>：借助统一内核与多线程渲染机制，复杂场景下UI响应延迟降低40%、用户交互成功率提升25%以上。</p>
<p>如在问界M9、小鹏G6等车型上，鸿蒙座舱系统实现“智慧语音 + 视觉感知 + 空间音效 + 多设备协同”的沉浸式体验，显著领先传统车机。</p>
<hr>
<p><strong>AOS：高实时性车控操作系统，提升系统响应稳定性</strong></p>
<blockquote>
<p>AOS是专为汽车底层控制场景设计的轻量级实时操作系统，以调度精度、冗余安全与定制能力为核心特性：</p></blockquote>
<p>精确控制如转向、电机、车身等关键子系统</p>
<p>对车规芯片如MCU/SoC适配性强，支持多线程任务管理与高优先级中断</p>
<p>与自研芯片联合优化，可实现端到端时延&lt;10ms、异常恢复时间&lt;100ms的性能表现</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">Jul 22, 2025</span>
  </footer>
</article>

        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/%E5%85%A8%E5%9F%9F%E9%A2%86%E8%88%AA%E8%BE%85%E5%8A%A9nop&#43;%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/">NOP主要功能设计逻辑图（状态机）</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><h1 id="全域领航辅助nop">全域领航辅助NOP+</h1>
<h2 id="1-产品概述">1. 产品概述</h2>
<p>全域领航辅助NOP+是一种舒适性功能，它是能让车辆根据导航规划好的路线进行行驶的辅助驾驶功能，能够完成如<strong>路口通行</strong>、导航变道、超车变道、绕向车辆等驾驶任务。在面对<strong>施工区域、通用障碍物等场景时，车辆具有</strong>安全能力，能够提供联通地面道路与城市快速路、高速公路的辅助驾驶体验。</p>
<p><img alt="image.png" loading="lazy" src="/images/nop_image.png"></p>
<h2 id="2-车型配置">2. 车型配置</h2>
<p>本文档中提出的 <strong>NOP+</strong> 全域领航辅助功能，配置在 ES8车型上。</p>
<h2 id="3-参考文档"><strong>3. 参考文档</strong></h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>文档编号</th>
          <th>文档名</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>GBT 20608-2006</td>
          <td>智能运输系统-自适应巡航控制系统-性能要求与检测方法</td>
      </tr>
      <tr>
          <td>2</td>
          <td>ISO 15622-2018</td>
          <td>Intelligent Transport Systems-Adaptive Cruise Control</td>
      </tr>
      <tr>
          <td>System-Performance Requirements and Test Procedures</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>3</td>
          <td>ISO 22179-2009</td>
          <td>Intelligent Transport Systems-Full Speed Range Adaptive Cruise</td>
      </tr>
      <tr>
          <td>Control (FSRA) Systems- Performance Requirements and Test</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>Procedures</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>4</td>
          <td>SAE J2399</td>
          <td>Adaptive Cruise Control (ACC) Operating Characteristics and</td>
      </tr>
      <tr>
          <td>User Interface</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>5</td>
          <td>i-VISTA GM-MM-A0-2020</td>
          <td>中国智能汽车指数管理办法 2020 版</td>
      </tr>
      <tr>
          <td>6</td>
          <td>i-VISTA SM-ADAS-ICAR-A0-2019</td>
          <td>智能行车辅助评价规程 2020 版</td>
      </tr>
      <tr>
          <td>7</td>
          <td>i-VISTA SM-ADAS-ICAT-A0-2019</td>
          <td>智能行车辅助试验规程 2020 版</td>
      </tr>
      <tr>
          <td>8</td>
          <td></td>
          <td><code>中华人民共和国道路交通安全法</code></td>
      </tr>
  </tbody>
</table>
<h2 id="4-名词解释">4. 名词解释</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>缩写</th>
          <th>全称</th>
          <th>注释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>ACC</td>
          <td>Adaptive Cruise Control</td>
          <td>自适应巡航控制</td>
      </tr>
      <tr>
          <td>2</td>
          <td>Stop&amp;Go</td>
          <td>Stop and Go</td>
          <td>自动启停</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Override</td>
          <td></td>
          <td>超驰</td>
      </tr>
      <tr>
          <td>4</td>
          <td>ODC</td>
          <td>Operational Design Condition</td>
          <td>运行设计条件</td>
      </tr>
      <tr>
          <td>5</td>
          <td>HMI</td>
          <td>Human-Machine Interface</td>
          <td>人机交互界面</td>
      </tr>
      <tr>
          <td>6</td>
          <td>TTC</td>
          <td>Time To Collision</td>
          <td>碰撞时间</td>
      </tr>
      <tr>
          <td>7</td>
          <td>LCC</td>
          <td>Lane Centering Control</td>
          <td>车道居中辅助</td>
      </tr>
      <tr>
          <td>8</td>
          <td>NP</td>
          <td>Nio Pilot</td>
          <td>包括highway pilot、拥堵自动辅助驾驶traffic jam pilot</td>
      </tr>
      <tr>
          <td>9</td>
          <td>NOP</td>
          <td>Navigation on Pilot</td>
          <td><strong>增强车道居中辅助</strong></td>
      </tr>
      <tr>
          <td>10</td>
          <td>NOP+</td>
          <td>Navigation on Pilot+</td>
          <td><strong>全域领航辅助</strong></td>
      </tr>
  </tbody>
</table>
<h2 id="5-子功能介绍">5. 子功能介绍</h2>
<p>自动辅助驾驶Pilot包括<strong>高速自动辅助驾驶（highway pilot）</strong>、<strong>拥堵自动辅助驾驶（traffic jam pilot)两种功能,</strong> 主要适用于车道线清晰及有进入限制的封闭道路上使用，譬如高速和高架的主路及拥堵路段，<strong>且在本车道内行驶，不会换道变道行驶</strong>。</p></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 20, 2025</span>
  </footer>
</article>

        
      </div>
    
      <h2 style="margin-top: 2rem;">感知模块</h2>
      <div class="post-list">
        
          <article class="post-entry">
  <header class="entry-header">
    <h2 class="entry-title">
      <a href="/posts/lidar_point_cloud_processing/">激光点云处理（Lidar Point Cloud Processing）</a>
    </h2>
  </header>
  <section class="entry-content">
    <p><p>激光雷达（Lidar）是自动驾驶中感知环境的核心传感器之一，它输出的是一帧帧<strong>点云数据（point cloud）</strong>，表示空间中障碍物的位置和形状。</p>
<hr>
<h2 id="1-什么是点云">1. 什么是点云？</h2>
<p>点云是由一系列点（x, y, z, intensity）组成的数据集，每个点表示空间中某个反射物的坐标和强度信息。</p>
<hr>
<h2 id="2-点云数据结构">2. 点云数据结构</h2>
<table>
  <thead>
      <tr>
          <th>字段</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>x, y, z</td>
          <td>三维坐标</td>
      </tr>
      <tr>
          <td>intensity</td>
          <td>激光反射强度</td>
      </tr>
      <tr>
          <td>ring</td>
          <td>激光束编号（多线雷达）</td>
      </tr>
      <tr>
          <td>timestamp</td>
          <td>每个点的时间戳</td>
      </tr>
      <tr>
          <td>reflectivity / ambient</td>
          <td>可选，反映表面材质或亮度</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="3-常见处理流程">3. 常见处理流程</h2>
<h3 id="31-点云预处理">3.1 点云预处理</h3>
<ul>
<li><strong>体素滤波（VoxelGrid）</strong>：降低点云密度，加快处理速度</li>
<li><strong>裁剪（CropBox）</strong>：去除远处或地面点，聚焦感兴趣区域</li>
<li><strong>时间同步</strong>：与IMU/GNSS同步，统一坐标系</li>
</ul>
<h3 id="32-点云配准与融合">3.2 点云配准与融合</h3>
<ul>
<li><strong>ICP算法（Iterative Closest Point）</strong>：配准不同帧点云，构建地图</li>
<li><strong>NDT算法</strong>：用于鲁棒配准，适应点云局部稀疏问题</li>
<li><strong>多帧融合</strong>：提升障碍检测的完整性</li>
</ul>
<h3 id="33-点云感知">3.3 点云感知</h3>
<ul>
<li><strong>地面分割（Ground Segmentation）</strong>：识别并移除地面点</li>
<li><strong>聚类（Euclidean Clustering）</strong>：提取独立目标（车辆、行人）</li>
<li><strong>目标跟踪与识别</strong>：结合深度学习模型进行物体分类</li>
</ul>
<hr>
<h2 id="4-使用工具与库">4. 使用工具与库</h2>
<table>
  <thead>
      <tr>
          <th>工具/库</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>PCL (Point Cloud Library)</strong></td>
          <td>最主流的C++点云处理库</td>
      </tr>
      <tr>
          <td><strong>Open3D</strong></td>
          <td>Python友好，支持可视化与处理</td>
      </tr>
      <tr>
          <td><strong>ROS + sensor_msgs/PointCloud2</strong></td>
          <td>ROS中点云标准消息格式</td>
      </tr>
      <tr>
          <td><strong>rviz</strong></td>
          <td>可视化点云、障碍物、车辆模型</td>
      </tr>
      <tr>
          <td><strong>Autoware/Apollo</strong></td>
          <td>提供全套点云感知模块</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="5-示例pcl聚类伪代码">5. 示例：PCL聚类伪代码</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>pcl<span style="color:#f92672">::</span>EuclideanClusterExtraction<span style="color:#f92672">&lt;</span>pcl<span style="color:#f92672">::</span>PointXYZ<span style="color:#f92672">&gt;</span> ec;
</span></span><span style="display:flex;"><span>ec.setClusterTolerance(<span style="color:#ae81ff">0.5</span>); <span style="color:#75715e">// 50cm内为一类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ec.setMinClusterSize(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>ec.setMaxClusterSize(<span style="color:#ae81ff">2500</span>);
</span></span><span style="display:flex;"><span>ec.setSearchMethod(tree);
</span></span><span style="display:flex;"><span>ec.setInputCloud(cloud_filtered);
</span></span><span style="display:flex;"><span>ec.extract(cluster_indices);
</span></span></code></pre></div><hr>
<h2 id="推荐学习资料">推荐学习资料</h2>
<ul>
<li><a href="https://pointclouds.org/documentation/">PCL官方文档</a></li>
<li><a href="http://www.open3d.org/docs/">Open3D教程</a></li>
<li>Apollo / Autoware 点云处理模块源码分析</li>
<li>Udacity Sensor Fusion Nanodegree</li>
</ul></p>
  </section>
  <footer class="entry-footer">
    <span class="entry-date">May 2, 2024</span>
  </footer>
</article>

        
      </div>
    
  </main>

    </main>
    
<script src="/js/cursor-effects.js"></script>
<script>
  new CursorEffects({
    size: 2,
    shape: 'star',
    zIndex: 9999,
  });
</script>
</body>

</html>
