<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>路径规划（二）从占用图到安全区域：四叉树（QuadTree）构建与凸包生成 | </title>
<meta name="keywords" content="四叉树, 占用图, 凸包, 路径规划, 局部避障">
<meta name="description" content="详解如何从占用图Occupancy Map生成QuadTree结构，并构建安全走廊区域用于机器人路径规划。">
<meta name="author" content="">
<link rel="canonical" href="/posts/quadtree_safearea/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/posts/quadtree_safearea/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="/posts/quadtree_safearea/">
  <meta property="og:title" content="路径规划（二）从占用图到安全区域：四叉树（QuadTree）构建与凸包生成">
  <meta property="og:description" content="详解如何从占用图Occupancy Map生成QuadTree结构，并构建安全走廊区域用于机器人路径规划。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-16T00:00:00+00:00">
    <meta property="article:tag" content="四叉树">
    <meta property="article:tag" content="占用图">
    <meta property="article:tag" content="凸包">
    <meta property="article:tag" content="路径规划">
    <meta property="article:tag" content="局部避障">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="路径规划（二）从占用图到安全区域：四叉树（QuadTree）构建与凸包生成">
<meta name="twitter:description" content="详解如何从占用图Occupancy Map生成QuadTree结构，并构建安全走廊区域用于机器人路径规划。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "路径规划（二）从占用图到安全区域：四叉树（QuadTree）构建与凸包生成",
      "item": "/posts/quadtree_safearea/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "路径规划（二）从占用图到安全区域：四叉树（QuadTree）构建与凸包生成",
  "name": "路径规划（二）从占用图到安全区域：四叉树（QuadTree）构建与凸包生成",
  "description": "详解如何从占用图Occupancy Map生成QuadTree结构，并构建安全走廊区域用于机器人路径规划。",
  "keywords": [
    "四叉树", "占用图", "凸包", "路径规划", "局部避障"
  ],
  "articleBody": "在自主移动机器人中，快速判断哪些区域是可通行的、哪些区域需要避障，是路径规划系统的关键。这里我采用 四叉树结构（QuadTree） 对占用图进行递归划分，再对空闲区域构建 凸包（Convex Hull），生成**连接图（Connectivity Graph）**从而生成可用于路径规划的安全走廊（Safe Corridor）。\n一、构建思路概览 参考了项目中 connective_quadtree.py 和 corridor_algorithm.py 中的实现，思路如下：\n1. 输入原始占用图（Occupancy Grid） 2. 使用 QuadTreeNode 递归划分空间, 根据RGB颜色判断： - 若区域为空（全白[255,255,255]或者接近全白）：标记为“自由区域” - 若包含障碍（RGB值大于白色）：继续细分（最多分到 min_size） - 黑色（[0,0,0]）表示障碍物 3. 收集所有自由叶子节点作为 Safe Area 候选 4. 为每个叶子节点生成其凸包边界 5. 输出凸包用于路径规划和约束构建 二、QuadTree 类详解（connective_quadtree.py） Quadtree: Quadtree 是一种树形数据结构，可以用于将二维空间递归划分成更小的矩形区域（占用和空闲区域）， 从整张地图作为根节点开始分裂出四个子区域，每个子区域根据RGB值判断是否有障碍物。 基于原始图像的RGB value来划分 树结构 QuadTree 类\n主要负责管理整个四叉树结构： root: 根节点 leaf_nodes: 所有自由（无障碍物）的叶节点列表 max_depth: 树的最大深度 QuadTreeNode 类\n表示四叉树中的单个节点： values: 节点对应的栅格值(RGB值比如[0,0,0])矩阵 _ru_indices: 节点在原始矩阵中的右上角索引 (i, j) id_sequence: 节点的ID序列，表示从根到该节点的路径 _neighbors: 节点的邻居 (左, 右, 上, 下) _children: 子节点列表 state: 节点状态 (FREE, MIX, FULL) 节点状态：\nFREE: 完全无障碍的区域， MIX: 包含障碍物和自由空间的混合区域，被作为下一个根节点继续分裂出四个子区域；一直划分到： 区域小于min_cell_size， 或者树达到最大深度max_depth FULL: 已达到最大深度的节点 分割过程：\n判断是否有障碍物 有障碍物，继续分割， 无障碍物，作为叶节点 递归处理每个子区域，直到达到最大深度或者子区域小于min_cell_size 收集所有FREE的叶节点 初始化： QuadTree类管理四叉树状态、更新地图、生成凸包、安全区域\nclass QuadTree: def __init__(self, value_matrix: np.ndarray, min_cell_size: int, num_splits:int=2): self.root = QuadTreeNode.init_root(value_matrix, self.max_depth, auto_split=True) self.leaf_nodes : list[QuadTreeNode] = [] self._collect_free_leaf_nodes(self.root) value_matrix: 占用图（二维矩阵），包含Occupancy grid的值 min_cell_size: 四叉树划分的最小区域 numb_split : 每个维度的分割次数，默认2 root 自动调用 QuadTreeNode.split() 对有障碍的区域递归分割 从占用栅格地图生成四叉树：\nquadtree = QuadTree(occupancy_grid, min_cell_size=5) 生成convex hull 什么是“凸包”？ 给定一组二维点，凸包就是 把所有点包围起来的最小凸多边形 就像用一根橡皮筋套住一堆钉子，松手后形成的边界线\n这里用SciPy 库中的 ConvexHull 算法，它基于 QuickHull 算法构建凸包\nhull = ConvexHull(points) 先确定两个距离最大的点，连接后构成线。然后寻找离线的最远的点，构成三角形。以此类推，向外快速扩展，直到所有点都在凸包内。\nquickhull： https://blog.csdn.net/shungry/article/details/104342366\n** 创建凸包函数** ：\n目标是生成安全区域凸包，即从所有 leaf node 中提取真实的可用点，然后对它们计算凸包 这里_create_convex_hulls 函数 提取了空闲点，针对free叶节点生成凸包 把这些点的局部坐标 [i, j] 转为全局地图上的 [y+i, x+j] 把这些点喂给 ConvexHull()，求出一个凸多边形边界线，将这些空闲点“包起来” 所以生成的是指定区域中安全区域的凸包 它是针对 每个叶子节点（即子块）分别做的 最终得到的是 多个小块区域中每块空闲区域的边界 from scipy.spatial import ConvexHull import numpy as np def _create_convex_hulls(self): \"\"\"Create convex hulls for leaf nodes. This method creates convex hulls for all free leaf nodes in the quadtree. The convex hulls are stored in the self.convex_hulls dictionary with the node's id_sequence as the key. \"\"\" self.convex_hulls = {} # 确保字典被初始化 for leaf_node in self.leaf_nodes: # 使用节点的正确属性获取顶点 vertices = np.array(leaf_node.vertices) # 检查顶点是否足够构成凸包（至少3个点） if len(vertices) \u003e= 3: # 计算凸包 hull = ConvexHull(vertices) # 存储凸包，使用节点的id_sequence作为键 self.convex_hulls[leaf_node.id_sequence] = hull else: # 如果点不足以形成凸包，可以跳过或记录警告 print(f\"Warning: Node {leaf_node.id_sequence} has insufficient vertices for convex hull\") subgrid_size 是当前四叉树节点对应子区域的边长。（比如64x64的格子，分裂三次，子区域就是8x8， 因为64/（2**3） = 8）\n更新四叉树 选择更新策略 局部更新 选择节点 直接筛选叶节点（当 叶节点少 或者障碍物多） 递归查找（叶节点多 或者障碍物少） 选择更新方式 基于占用地图更新 基于几何位置更新 更新凸包 全局更新 更新凸包 收集ref path上的节点（collect_tree_nodes_on_path） 转换参考路径到占用地图坐标 筛选接近路径的叶节点 转换节点信息回到原始几何坐标系 动态更新与规划 (dynamic_update_and_plan)\n遍历时间步长 更新地图 (update_quadtree_with_obstacle) 更新安全区域 (_create_convex_hulls) 调用规划器 (planner.plan) 执行单步动作 (robot.execute) 递归收集自由区域： def _collect_free_leaf_nodes(self, node: \"QuadTreeNode\"): if node.is_leaf and node.state == TreeNodeState.FREE: self.leaf_nodes.append(node) else: for child in node.children: self._collect_free_leaf_nodes(child) 只收集纯白区域（全为自由）的叶子节点作为路径候选区域。\n遇到动态障碍物更新局部地图 只更新靠近动态障碍物的节点：对障碍物所在区域进行分裂或者合并，其他地图部分保持不变 “is_node_affected”函数 用来判断某个四叉树节点是否被动态障碍物“影响”或“覆盖”\n只要障碍物的中心点在“节点的边界 + 半径扩展区域”内，就认为该节点被影响。\n节点是一个矩形区域\n把这个矩形向外扩张 obstacle_radius\n看障碍物的中心 (x, y) 有没有落在这个扩张后的区域内\nx_min - r \u003c= x \u003c= x_max + r and y_min - r \u003c= y \u003c= y_max + r def update_quadtree_with_obstacle(self, obstacle_position: tuple, obstacle_radius: float): def is_node_affected(node, obstacle_position, obstacle_radius): # Check if the node intersects with the obstacle's influence radius x_min, x_max, y_min, y_max = node.get_bounds() x, y = obstacle_position return ( x_min - obstacle_radius \u003c= x \u003c= x_max + obstacle_radius and y_min - obstacle_radius \u003c= y \u003c= y_max + obstacle_radius ) def recursive_update(node): if is_node_affected(node, obstacle_position, obstacle_radius): if not node.is_leaf(): # Recursively check children for child in node.children: recursive_update(child) else: # If it's a leaf node and affected, decide whether to split or mark as occupied if node.size \u003e self.min_cell_size: node.split() else: node.mark_occupied() # Mark the node as occupied elif node.is_leaf(): # Merge unaffected nodes if previously split node.merge() recursive_update(self.root) self._collect_free_leaf_nodes(self.root) 如果障碍物正好在两个路径中间？ 动态规划器需要重新规划局部路径 如果障碍物速度大于机器人？ 需要提前预测障碍物路径， 以及提高响应速度（通过缩短规划的窗口时间） 邻居节点关系更新：需要重新计算邻居节点（分裂、合并） # 邻居关系更新 def update_neighbors(node): \"\"\" Update the neighbor relationships for a given node. \"\"\" for neighbor in node.neighbors: if neighbor.is_leaf(): # Update neighbor relationship based on current structure neighbor.neighbors = [n for n in neighbor.get_adjacent_nodes()] 动态障碍更新convex hull： 更新地图：update_quadtree_with_obstacle() 更新安全区域凸包：_create_convex_hulls() 基于新的安全区域 convex hull 进行路径规划 基于最新空闲区域动态生成“可行走区域凸包” def dynamic_update_and_plan(self, obstacle_positions, time_horizon) 收集reference path 上的tree node 输出靠近路径的空闲区域块 找出所有靠近这条路径的 FREE 格子，把它们标记出来，给后续路径规划使用。 def collect_tree_nodes_on_path(self, reference_path: list[PathNode], height_occupancy: int, threshold: float, rescale_geo_occupancy: int, rescale_geo_inflated_occupancy:float): 与MPC集成 要将QuadTree生成的数据与MPC集成需要: 生成参考路径 使用QuadTree分析环境并提取安全区域 将安全区域作为MPC的约束条件 三、QuadTreeNode 如何判断状态？ QuadTreeNode具体区域块的状态、自主分裂、判断空闲/占用/边界\n@property def state(self) -\u003e TreeNodeState: if np.all(self.values \u003c 0.01): return TreeNodeState.FREE elif len(self.id_sequence) == self._max_depth: return TreeNodeState.FULL else: return TreeNodeState.MIX FREE: 纯白，无障碍的归为free状态 FULL: 不是纯白，但是已经到达最大深度，也记为有障碍物区域 MIX: 不是纯白，也不是最大深度，尚可继续划分 四、QuadTreeNode节点级别生成凸包用于安全区域 #节点级别凸包运算，返回的凸包列表可以直接用于路径规划、安全区域描述或导航约束。 def path_tree_nodes_convexhull(self, path_tree_nodes: dict[tuple, \"QuadTreeNode\"]): path_convex_hulls = [] for key, tn in path_tree_nodes.items(): vertices = np.array(tn.vertices) # Compute convex hull for transformed vertices hull = ConvexHull(tn.vertices) # Store convex hull along with transformed vertices in the dictionary path_convex_hulls.append(hull) return path_convex_hulls 然后update_Quadtree\nfor node in 当前的所有叶子节点: 提取对应新地图中的这块区域 new_subgrid if new_subgrid 有障碍物（值是 [0,0,0]）: if node 可以继续分裂: node.split() 替换掉原来的节点 else: 直接删掉这个叶子节点 else: 保持原样 在 corridor_algorithm.py 中，我们对自由节点生成凸包：\nfor leaf_node in self.leaf_nodes: points = np.array([[y, x], [y, x+size], [y+size, x+size], [y+size, x]]) hull = ConvexHull(points) self.convex_hulls.append(hull) 每个叶子节点四角为一组点，生成凸包用于边界描述。若多个凸包连续排列，可合并为更大的 Safe Corridor。\n五、可选增强：凸包与路径的交集过滤 reference_line = LineString(reference_cells_occupancy) for hull in self.convex_hulls: if Polygon(hull.points[hull.vertices]).intersects(reference_line): path_convex_hulls.append(hull) 该功能允许筛选出与路径相关的安全区域，用于构造 MPC 约束。\n六、小结与下一篇预告 这一部分完成了以下目标：\n输入占用图，构建四叉树结构； 识别自由空间，并生成其凸包； 可用于路径规划前的地图预处理和约束区域定义。 下一篇讲解如何合并多个 safe area 以简化规划图结构，并构造连接图（Connectivity Graph）用于强化路径连通性。\n",
  "wordCount" : "680",
  "inLanguage": "en",
  "datePublished": "2025-05-16T00:00:00Z",
  "dateModified": "2025-05-16T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/quadtree_safearea/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>


</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      路径规划（二）从占用图到安全区域：四叉树（QuadTree）构建与凸包生成
    </h1>
    <div class="post-description">
      详解如何从占用图Occupancy Map生成QuadTree结构，并构建安全走廊区域用于机器人路径规划。
    </div>
    <div class="post-meta"><span title='2025-05-16 00:00:00 +0000 UTC'>May 16, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>在自主移动机器人中，快速判断哪些区域是可通行的、哪些区域需要避障，是路径规划系统的关键。这里我采用 <strong>四叉树结构（QuadTree）</strong> 对占用图进行递归划分，再对空闲区域构建 <strong>凸包（Convex Hull）</strong>，生成**连接图（Connectivity Graph）**从而生成可用于路径规划的安全走廊（Safe Corridor）。</p>
<hr>
<h2 id="一构建思路概览">一、构建思路概览<a hidden class="anchor" aria-hidden="true" href="#一构建思路概览">#</a></h2>
<p>参考了项目中 <code>connective_quadtree.py</code> 和 <code>corridor_algorithm.py</code> 中的实现，思路如下：</p>
<pre tabindex="0"><code>1. 输入原始占用图（Occupancy Grid）
2. 使用 QuadTreeNode 递归划分空间, 根据RGB颜色判断：
    - 若区域为空（全白[255,255,255]或者接近全白）：标记为“自由区域”
    - 若包含障碍（RGB值大于白色）：继续细分（最多分到 min_size）
    - 黑色（[0,0,0]）表示障碍物
3. 收集所有自由叶子节点作为 Safe Area 候选
4. 为每个叶子节点生成其凸包边界
5. 输出凸包用于路径规划和约束构建
</code></pre><hr>
<h2 id="二quadtree-类详解connective_quadtreepy">二、QuadTree 类详解（connective_quadtree.py）<a hidden class="anchor" aria-hidden="true" href="#二quadtree-类详解connective_quadtreepy">#</a></h2>
<h3 id="quadtree">Quadtree:<a hidden class="anchor" aria-hidden="true" href="#quadtree">#</a></h3>
<pre tabindex="0"><code>Quadtree 是一种树形数据结构，可以用于将二维空间递归划分成更小的矩形区域（占用和空闲区域），
从整张地图作为根节点开始分裂出四个子区域，每个子区域根据RGB值判断是否有障碍物。
</code></pre><p>基于原始图像的RGB value来划分
<img alt="四叉树二维图" loading="lazy" src="/images/Design_Course_map3__3__3.png"></p>
<p>树结构
<img alt="四叉树树结构" loading="lazy" src="/images/Design_Course_map4_4.png"></p>
<ol>
<li>
<p><strong>QuadTree 类</strong></p>
<ul>
<li>主要负责管理整个四叉树结构：</li>
<li>root: 根节点</li>
<li>leaf_nodes: 所有自由（无障碍物）的叶节点列表</li>
<li>max_depth: 树的最大深度</li>
</ul>
</li>
<li>
<p><strong>QuadTreeNode 类</strong></p>
<ul>
<li>表示四叉树中的单个节点：</li>
<li>values: 节点对应的栅格值(RGB值比如[0,0,0])矩阵</li>
<li>_ru_indices: 节点在原始矩阵中的右上角索引 (i, j)</li>
<li>id_sequence: 节点的ID序列，表示从根到该节点的路径</li>
<li>_neighbors: 节点的邻居 (左, 右, 上, 下)</li>
<li>_children: 子节点列表</li>
<li>state: 节点状态 (FREE, MIX, FULL)</li>
</ul>
</li>
<li>
<p><strong>节点状态</strong>：</p>
<ul>
<li>FREE: 完全无障碍的区域，</li>
<li>MIX: 包含障碍物和自由空间的混合区域，被作为下一个根节点继续分裂出四个子区域；一直划分到：
<ul>
<li>区域小于min_cell_size，</li>
<li>或者树达到最大深度max_depth</li>
</ul>
</li>
<li>FULL: 已达到最大深度的节点</li>
</ul>
</li>
<li>
<p><strong>分割过程</strong>：</p>
</li>
</ol>
<ul>
<li>判断是否有障碍物</li>
<li>有障碍物，继续分割， 无障碍物，作为叶节点</li>
<li>递归处理每个子区域，直到达到最大深度或者子区域小于min_cell_size</li>
<li>收集所有FREE的叶节点</li>
</ul>
<h3 id="初始化">初始化：<a hidden class="anchor" aria-hidden="true" href="#初始化">#</a></h3>
<p><strong>QuadTree</strong>类管理四叉树状态、更新地图、生成凸包、安全区域</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">QuadTree</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, value_matrix: np<span style="color:#f92672">.</span>ndarray, min_cell_size: int, num_splits:int<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>root <span style="color:#f92672">=</span> QuadTreeNode<span style="color:#f92672">.</span>init_root(value_matrix, self<span style="color:#f92672">.</span>max_depth, auto_split<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>leaf_nodes : list[QuadTreeNode] <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_collect_free_leaf_nodes(self<span style="color:#f92672">.</span>root)
</span></span></code></pre></div><ul>
<li><code>value_matrix</code>: 占用图（二维矩阵），包含Occupancy grid的值</li>
<li><code>min_cell_size</code>: 四叉树划分的最小区域</li>
<li><code>numb_split</code> : 每个维度的分割次数，默认2</li>
<li>root 自动调用 <code>QuadTreeNode.split()</code> 对有障碍的区域递归分割</li>
</ul>
<p>从占用栅格地图生成四叉树：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>quadtree <span style="color:#f92672">=</span> QuadTree(occupancy_grid, min_cell_size<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)
</span></span></code></pre></div><h3 id="生成convex-hull">生成convex hull<a hidden class="anchor" aria-hidden="true" href="#生成convex-hull">#</a></h3>
<p>什么是“凸包”？
给定一组二维点，凸包就是 把所有点包围起来的最小凸多边形
就像用一根橡皮筋套住一堆钉子，松手后形成的边界线</p>
<p><img alt="凸包" loading="lazy" src="/images/convex_hull.png"></p>
<p>这里用SciPy 库中的 <strong>ConvexHull</strong> 算法，它基于 <strong>QuickHull</strong> 算法构建凸包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>hull <span style="color:#f92672">=</span> ConvexHull(points)
</span></span></code></pre></div><p>先确定两个距离最大的点，连接后构成线。然后寻找离线的最远的点，构成三角形。以此类推，向外快速扩展，直到所有点都在凸包内。</p>
<p>quickhull：
<img alt="quickhull图示" loading="lazy" src="/images/quickhull.png"></p>
<blockquote>
<p><a href="https://blog.csdn.net/shungry/article/details/104342366">https://blog.csdn.net/shungry/article/details/104342366</a></p></blockquote>
<p>** 创建凸包函数** ：</p>
<ul>
<li>目标是生成安全区域凸包，即从所有 <strong>leaf node</strong> 中提取真实的可用点，然后对它们计算凸包
<ul>
<li>这里_create_convex_hulls 函数 提取了空闲点，针对free叶节点生成凸包</li>
<li>把这些点的局部坐标 [i, j] 转为全局地图上的 [y+i, x+j]</li>
<li>把这些点喂给 ConvexHull()，求出一个凸多边形边界线，将这些空闲点“包起来”</li>
</ul>
</li>
<li>所以生成的是<strong>指定区域中安全区域的凸包</strong>
<ul>
<li>它是针对 每个叶子节点（即子块）分别做的</li>
<li>最终得到的是 多个小块区域中每块空闲区域的边界</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy.spatial <span style="color:#f92672">import</span> ConvexHull
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_create_convex_hulls</span>(self):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;Create convex hulls for leaf nodes.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    This method creates convex hulls for all free leaf nodes in the quadtree.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    The convex hulls are stored in the self.convex_hulls dictionary with the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    node&#39;s id_sequence as the key.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>convex_hulls <span style="color:#f92672">=</span> {}  <span style="color:#75715e"># 确保字典被初始化</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> leaf_node <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>leaf_nodes:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 使用节点的正确属性获取顶点</span>
</span></span><span style="display:flex;"><span>        vertices <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(leaf_node<span style="color:#f92672">.</span>vertices)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 检查顶点是否足够构成凸包（至少3个点）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(vertices) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 计算凸包</span>
</span></span><span style="display:flex;"><span>            hull <span style="color:#f92672">=</span> ConvexHull(vertices)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 存储凸包，使用节点的id_sequence作为键</span>
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>convex_hulls[leaf_node<span style="color:#f92672">.</span>id_sequence] <span style="color:#f92672">=</span> hull
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 如果点不足以形成凸包，可以跳过或记录警告</span>
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Warning: Node </span><span style="color:#e6db74">{</span>leaf_node<span style="color:#f92672">.</span>id_sequence<span style="color:#e6db74">}</span><span style="color:#e6db74"> has insufficient vertices for convex hull&#34;</span>)
</span></span><span style="display:flex;"><span>            
</span></span></code></pre></div><p>subgrid_size 是当前四叉树节点对应子区域的边长。（比如64x64的格子，分裂三次，子区域就是8x8， 因为64/（2**3） = 8）</p>
<h3 id="更新四叉树">更新四叉树<a hidden class="anchor" aria-hidden="true" href="#更新四叉树">#</a></h3>
<ul>
<li>选择更新策略
<ul>
<li>局部更新
<ul>
<li>选择节点
<ul>
<li>直接筛选叶节点（当 叶节点少 或者障碍物多）</li>
<li>递归查找（叶节点多 或者障碍物少）</li>
</ul>
</li>
<li>选择更新方式
<ul>
<li>基于占用地图更新</li>
<li>基于几何位置更新</li>
</ul>
</li>
<li>更新凸包</li>
</ul>
</li>
<li>全局更新</li>
</ul>
</li>
<li>更新凸包</li>
</ul>
<h3 id="收集ref-path上的节点collect_tree_nodes_on_path">收集ref path上的节点（collect_tree_nodes_on_path）<a hidden class="anchor" aria-hidden="true" href="#收集ref-path上的节点collect_tree_nodes_on_path">#</a></h3>
<ul>
<li>转换参考路径到占用地图坐标</li>
<li>筛选接近路径的叶节点</li>
<li>转换节点信息回到原始几何坐标系</li>
</ul>
<p>动态更新与规划 (dynamic_update_and_plan)</p>
<ul>
<li>遍历时间步长
<ul>
<li>更新地图 (update_quadtree_with_obstacle)</li>
<li>更新安全区域 (_create_convex_hulls)</li>
<li>调用规划器 (planner.plan)</li>
<li>执行单步动作 (robot.execute)</li>
</ul>
</li>
</ul>
<h3 id="递归收集自由区域">递归收集自由区域：<a hidden class="anchor" aria-hidden="true" href="#递归收集自由区域">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_collect_free_leaf_nodes</span>(self, node: <span style="color:#e6db74">&#34;QuadTreeNode&#34;</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>is_leaf <span style="color:#f92672">and</span> node<span style="color:#f92672">.</span>state <span style="color:#f92672">==</span> TreeNodeState<span style="color:#f92672">.</span>FREE:
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>leaf_nodes<span style="color:#f92672">.</span>append(node)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> child <span style="color:#f92672">in</span> node<span style="color:#f92672">.</span>children:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>_collect_free_leaf_nodes(child)
</span></span></code></pre></div><p>只收集纯白区域（全为自由）的叶子节点作为路径候选区域。</p>
<h3 id="遇到动态障碍物更新局部地图">遇到动态障碍物更新局部地图<a hidden class="anchor" aria-hidden="true" href="#遇到动态障碍物更新局部地图">#</a></h3>
<ol>
<li>只更新靠近动态障碍物的节点：对障碍物所在区域进行分裂或者合并，其他地图部分保持不变
<ul>
<li>
<p>“is_node_affected”函数 用来判断某个四叉树节点是否<strong>被动态障碍物</strong>“影响”或“覆盖”</p>
</li>
<li>
<p>只要障碍物的中心点在“节点的边界 + 半径扩展区域”内，就认为该节点被影响。</p>
<ul>
<li>
<p>节点是一个矩形区域</p>
</li>
<li>
<p>把这个矩形向外扩张 obstacle_radius</p>
</li>
<li>
<p>看障碍物的中心 (x, y) 有没有落在这个扩张后的区域内</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x_min <span style="color:#f92672">-</span> r <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&lt;=</span>  x_max <span style="color:#f92672">+</span> r  <span style="color:#f92672">and</span>  y_min <span style="color:#f92672">-</span> r <span style="color:#f92672">&lt;=</span>  y <span style="color:#f92672">&lt;=</span>  y_max <span style="color:#f92672">+</span> r
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">update_quadtree_with_obstacle</span>(self, obstacle_position: tuple, obstacle_radius: float):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_node_affected</span>(node, obstacle_position, obstacle_radius):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Check if the node intersects with the obstacle&#39;s influence radius</span>
</span></span><span style="display:flex;"><span>            x_min, x_max, y_min, y_max <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>get_bounds()
</span></span><span style="display:flex;"><span>            x, y <span style="color:#f92672">=</span> obstacle_position
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>                x_min <span style="color:#f92672">-</span> obstacle_radius <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&lt;=</span> x_max <span style="color:#f92672">+</span> obstacle_radius <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>                y_min <span style="color:#f92672">-</span> obstacle_radius <span style="color:#f92672">&lt;=</span> y <span style="color:#f92672">&lt;=</span> y_max <span style="color:#f92672">+</span> obstacle_radius
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recursive_update</span>(node):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> is_node_affected(node, obstacle_position, obstacle_radius):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> node<span style="color:#f92672">.</span>is_leaf():
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># Recursively check children</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span> child <span style="color:#f92672">in</span> node<span style="color:#f92672">.</span>children:
</span></span><span style="display:flex;"><span>                        recursive_update(child)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># If it&#39;s a leaf node and affected, decide whether to split or mark as occupied</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>size <span style="color:#f92672">&gt;</span> self<span style="color:#f92672">.</span>min_cell_size:
</span></span><span style="display:flex;"><span>                        node<span style="color:#f92672">.</span>split()
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                        node<span style="color:#f92672">.</span>mark_occupied()  <span style="color:#75715e"># Mark the node as occupied</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> node<span style="color:#f92672">.</span>is_leaf():
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Merge unaffected nodes if previously split</span>
</span></span><span style="display:flex;"><span>                node<span style="color:#f92672">.</span>merge()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        recursive_update(self<span style="color:#f92672">.</span>root)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_collect_free_leaf_nodes(self<span style="color:#f92672">.</span>root)
</span></span><span style="display:flex;"><span>     
</span></span></code></pre></div><ul>
<li>如果障碍物正好在两个路径中间？ 动态规划器需要重新规划局部路径</li>
<li>如果障碍物速度大于机器人？ 需要提前预测障碍物路径， 以及提高响应速度（通过缩短规划的窗口时间）</li>
</ul>
<ol start="2">
<li>邻居节点关系更新：需要重新计算邻居节点（分裂、合并）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 邻居关系更新   </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">update_neighbors</span>(node):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Update the neighbor relationships for a given node.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> neighbor <span style="color:#f92672">in</span> node<span style="color:#f92672">.</span>neighbors:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> neighbor<span style="color:#f92672">.</span>is_leaf():
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Update neighbor relationship based on current structure</span>
</span></span><span style="display:flex;"><span>                neighbor<span style="color:#f92672">.</span>neighbors <span style="color:#f92672">=</span> [n <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> neighbor<span style="color:#f92672">.</span>get_adjacent_nodes()]
</span></span></code></pre></div><ol start="3">
<li>动态障碍更新convex hull：
<ol>
<li>更新地图：update_quadtree_with_obstacle()</li>
<li>更新安全区域凸包：_create_convex_hulls()</li>
<li>基于新的安全区域 convex hull 进行路径规划
基于最新空闲区域动态生成“可行走区域凸包”</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dynamic_update_and_plan</span>(self, obstacle_positions, time_horizon)
</span></span></code></pre></div><ol start="4">
<li>收集reference path 上的tree node 输出靠近路径的空闲区域块</li>
</ol>
<ul>
<li>找出所有靠近这条路径的 FREE 格子，把它们标记出来，给后续路径规划使用。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">collect_tree_nodes_on_path</span>(self, reference_path: list[PathNode], height_occupancy: int, threshold: float, rescale_geo_occupancy: int, rescale_geo_inflated_occupancy:float):
</span></span></code></pre></div><ul>
<li>与MPC集成
要将QuadTree生成的数据与MPC集成需要:
<ul>
<li>生成参考路径</li>
<li>使用QuadTree分析环境并提取安全区域</li>
<li>将安全区域作为MPC的约束条件</li>
</ul>
</li>
</ul>
<hr>
<h2 id="三quadtreenode-如何判断状态">三、QuadTreeNode 如何判断状态？<a hidden class="anchor" aria-hidden="true" href="#三quadtreenode-如何判断状态">#</a></h2>
<p><strong>QuadTreeNode</strong>具体区域块的状态、自主分裂、判断空闲/占用/边界</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a6e22e">@property</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">state</span>(self) <span style="color:#f92672">-&gt;</span> TreeNodeState:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> np<span style="color:#f92672">.</span>all(self<span style="color:#f92672">.</span>values <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.01</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TreeNodeState<span style="color:#f92672">.</span>FREE
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> len(self<span style="color:#f92672">.</span>id_sequence) <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>_max_depth:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TreeNodeState<span style="color:#f92672">.</span>FULL
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TreeNodeState<span style="color:#f92672">.</span>MIX
</span></span></code></pre></div><ul>
<li><code>FREE</code>: 纯白，无障碍的归为free状态</li>
<li><code>FULL</code>: 不是纯白，但是已经到达最大深度，也记为有障碍物区域</li>
<li><code>MIX</code>: 不是纯白，也不是最大深度，尚可继续划分</li>
</ul>
<hr>
<h2 id="四quadtreenode节点级别生成凸包用于安全区域">四、QuadTreeNode节点级别生成凸包用于安全区域<a hidden class="anchor" aria-hidden="true" href="#四quadtreenode节点级别生成凸包用于安全区域">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#节点级别凸包运算，返回的凸包列表可以直接用于路径规划、安全区域描述或导航约束。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">path_tree_nodes_convexhull</span>(self, path_tree_nodes: dict[tuple, <span style="color:#e6db74">&#34;QuadTreeNode&#34;</span>]):
</span></span><span style="display:flex;"><span>        path_convex_hulls <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> key, tn <span style="color:#f92672">in</span> path_tree_nodes<span style="color:#f92672">.</span>items():
</span></span><span style="display:flex;"><span>            vertices <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(tn<span style="color:#f92672">.</span>vertices)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Compute convex hull for transformed vertices</span>
</span></span><span style="display:flex;"><span>            hull <span style="color:#f92672">=</span> ConvexHull(tn<span style="color:#f92672">.</span>vertices)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Store convex hull along with transformed vertices in the dictionary</span>
</span></span><span style="display:flex;"><span>            path_convex_hulls<span style="color:#f92672">.</span>append(hull)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> path_convex_hulls
</span></span></code></pre></div><p>然后<code>update_Quadtree</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> node <span style="color:#f92672">in</span> 当前的所有叶子节点:
</span></span><span style="display:flex;"><span>    提取对应新地图中的这块区域 new_subgrid
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> new_subgrid 有障碍物<span style="color:#960050;background-color:#1e0010">（</span>值是 [<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>]<span style="color:#960050;background-color:#1e0010">）</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> node 可以继续分裂:
</span></span><span style="display:flex;"><span>            node<span style="color:#f92672">.</span>split()
</span></span><span style="display:flex;"><span>            替换掉原来的节点
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            直接删掉这个叶子节点
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        保持原样
</span></span></code></pre></div><p>在 <code>corridor_algorithm.py</code> 中，我们对自由节点生成凸包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> leaf_node <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>leaf_nodes:
</span></span><span style="display:flex;"><span>    points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[y, x], [y, x<span style="color:#f92672">+</span>size], [y<span style="color:#f92672">+</span>size, x<span style="color:#f92672">+</span>size], [y<span style="color:#f92672">+</span>size, x]])
</span></span><span style="display:flex;"><span>    hull <span style="color:#f92672">=</span> ConvexHull(points)
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>convex_hulls<span style="color:#f92672">.</span>append(hull)
</span></span></code></pre></div><p>每个叶子节点四角为一组点，生成凸包用于边界描述。若多个凸包连续排列，可合并为更大的 Safe Corridor。</p>
<hr>
<h2 id="五可选增强凸包与路径的交集过滤">五、可选增强：凸包与路径的交集过滤<a hidden class="anchor" aria-hidden="true" href="#五可选增强凸包与路径的交集过滤">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>reference_line <span style="color:#f92672">=</span> LineString(reference_cells_occupancy)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> hull <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>convex_hulls:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> Polygon(hull<span style="color:#f92672">.</span>points[hull<span style="color:#f92672">.</span>vertices])<span style="color:#f92672">.</span>intersects(reference_line):
</span></span><span style="display:flex;"><span>        path_convex_hulls<span style="color:#f92672">.</span>append(hull)
</span></span></code></pre></div><p>该功能允许筛选出与路径相关的安全区域，用于构造 MPC 约束。</p>
<hr>
<h2 id="六小结与下一篇预告">六、小结与下一篇预告<a hidden class="anchor" aria-hidden="true" href="#六小结与下一篇预告">#</a></h2>
<p>这一部分完成了以下目标：</p>
<ul>
<li>输入占用图，构建四叉树结构；</li>
<li>识别自由空间，并生成其凸包；</li>
<li>可用于路径规划前的地图预处理和约束区域定义。</li>
</ul>
<p>下一篇讲解如何合并多个 safe area 以简化规划图结构，并构造连接图（Connectivity Graph）用于强化路径连通性。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E5%9B%9B%E5%8F%89%E6%A0%91/">四叉树</a></li>
      <li><a href="/tags/%E5%8D%A0%E7%94%A8%E5%9B%BE/">占用图</a></li>
      <li><a href="/tags/%E5%87%B8%E5%8C%85/">凸包</a></li>
      <li><a href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></li>
      <li><a href="/tags/%E5%B1%80%E9%83%A8%E9%81%BF%E9%9A%9C/">局部避障</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<script src="/js/cursor-effects.js"></script>
<script>
  new CursorEffects({
    size: 2,
    shape: 'star',
    zIndex: 9999,
  });
</script>
</body>

</html>
